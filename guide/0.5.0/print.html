<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Shipyard User&#x27;s Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="welcome.html">Welcome</a></li><li class="chapter-item expanded "><a href="fundamentals.html"><strong aria-hidden="true">1.</strong> Fundamentals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fundamentals/world.html"><strong aria-hidden="true">1.1.</strong> World</a></li><li class="chapter-item expanded "><a href="fundamentals/add-entity.html"><strong aria-hidden="true">1.2.</strong> Add Entity</a></li><li class="chapter-item expanded "><a href="fundamentals/delete-entity.html"><strong aria-hidden="true">1.3.</strong> Delete Entity</a></li><li class="chapter-item expanded "><a href="fundamentals/add-components.html"><strong aria-hidden="true">1.4.</strong> Add Components</a></li><li class="chapter-item expanded "><a href="fundamentals/remove-components.html"><strong aria-hidden="true">1.5.</strong> Remove Components</a></li><li class="chapter-item expanded "><a href="fundamentals/delete-components.html"><strong aria-hidden="true">1.6.</strong> Delete Components</a></li><li class="chapter-item expanded "><a href="fundamentals/get-and-modify.html"><strong aria-hidden="true">1.7.</strong> Get and Modify Components</a></li><li class="chapter-item expanded "><a href="fundamentals/iterators.html"><strong aria-hidden="true">1.8.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="fundamentals/uniques.html"><strong aria-hidden="true">1.9.</strong> Uniques</a></li><li class="chapter-item expanded "><a href="fundamentals/systems.html"><strong aria-hidden="true">1.10.</strong> Systems</a></li></ol></li><li class="chapter-item expanded "><a href="going-further.html"><strong aria-hidden="true">2.</strong> Going Further</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="going-further/sparse-set.html"><strong aria-hidden="true">2.1.</strong> Sparse Set</a></li><li class="chapter-item expanded "><a href="going-further/parallelism.html"><strong aria-hidden="true">2.2.</strong> Parallelism</a></li><li class="chapter-item expanded "><a href="going-further/non-send-sync.html"><strong aria-hidden="true">2.3.</strong> !Send and !Sync Components</a></li><li class="chapter-item expanded "><a href="going-further/performance-tips.html"><strong aria-hidden="true">2.4.</strong> Performance Tips</a></li></ol></li><li class="chapter-item expanded "><a href="recipes.html"><strong aria-hidden="true">3.</strong> Recipes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="recipes/hierarchy.html"><strong aria-hidden="true">3.1.</strong> Hierarchy</a></li><li class="chapter-item expanded "><a href="recipes/seed.html"><strong aria-hidden="true">3.2.</strong> Seed</a></li><li class="chapter-item expanded "><a href="recipes/0.4-migration.html"><strong aria-hidden="true">3.3.</strong> 0.4 migration</a></li></ol></li><li class="chapter-item expanded "><a href="pilgrimage.html"><strong aria-hidden="true">4.</strong> Pilgrimage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pilgrimage/more-resources.html"><strong aria-hidden="true">4.1.</strong> More Resources</a></li><li class="chapter-item expanded "><a href="pilgrimage/related-crates.html"><strong aria-hidden="true">4.2.</strong> Shipyard Related Crates</a></li><li class="chapter-item expanded "><a href="pilgrimage/projects-using-shipyard.html"><strong aria-hidden="true">4.3.</strong> Projects using Shipyard</a></li></ol></li><li class="chapter-item expanded "><a href="contributors.html"><strong aria-hidden="true">5.</strong> Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Shipyard User&#x27;s Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-shipyard"><a class="header" href="#welcome-to-shipyard">Welcome to Shipyard!</a></h1>
<p><a href="https://github.com/leudz/shipyard">Shipyard</a> is an Entity Component System focused on usability and speed. ECS is a great way to organize logic and data.</p>
<p>There are two main benefits to using an ECS:</p>
<ol>
<li>Elegant approach for humans
<ul>
<li>Composition over inheritance</li>
<li>Separation of concerns</li>
<li>Less burdened by lifetimes</li>
</ul>
</li>
<li>Optimal design for computers
<ul>
<li>Spatial locality</li>
<li>Less pointer chasing</li>
</ul>
</li>
</ol>
<p>However, programming with an ECS requires thinking about data and logic in a different way than you might be used to.</p>
<h1 id="how-does-it-work"><a class="header" href="#how-does-it-work">How does it work?</a></h1>
<p>Components hold data. Entities are simple ids used to refer to a group of components.</p>
<p>Systems do the heavy lifting: updating components, running side-effects, and integrating with other parts of the code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamentals"><a class="header" href="#fundamentals">Fundamentals</a></h1>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>For most target architectures you can just add it to <code>Cargo.toml</code>.</p>
<p>For single-threaded environments (like WASM) or embedded you'll need to turn off default features and add features back in when needed.</p>
<p>Now that we're ready to use Shipyard, let's learn the basics!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="world"><a class="header" href="#world">World</a></h1>
<p><a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.World.html"><code>World</code></a> is Shipyard's core data structure: It holds all data and knows how to process systems. All operations originate from one (or more) <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.World.html"><code>World</code></a>.</p>
<h2 id="creation"><a class="header" href="#creation">Creation</a></h2>
<p>You can use <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.World.html#method.new"><code>new</code></a> or <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.World.html#method.default"><code>default</code></a>:</p>
<pre><code class="language-rust  noplaypen">let world = World::default();
let world = World::new();</code></pre>
<p>There is no need to register components, storages are created on first access.</p>
<h2 id="views"><a class="header" href="#views">Views</a></h2>
<p>While some actions are available directly on <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.World.html"><code>World</code></a>, you'll often interact with it through views. They allow access to one or multiple storage.<br />
Storage access follows the same rules as Rust's borrowing: You can have as many shared accesses to a storage as you like or a single exclusive access.</p>
<p>You can request a view using <a href="https://docs.rs/shipyard/0.4.1/shipyard/struct.World.html#method.borrow"><code>World::borrow</code></a>, <a href="https://docs.rs/shipyard/0.4.1/shipyard/struct.World.html#method.run"><code>World::run</code></a> or in workloads (more on this in a later chapter).</p>
<p>For example if you want a shared access to the entities storage you can use <a href="https://docs.rs/shipyard/0.4.1/shipyard/struct.World.html#method.borrow"><code>borrow</code></a>:</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

let entities = world.borrow::&lt;EntitiesView&gt;().unwrap();</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-entity"><a class="header" href="#add-entity">Add Entity</a></h1>
<p>When an entity is created you will receive a unique handle to it: an <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.EntityId.html"><code>EntityId</code></a>.</p>
<h2 id="world-1"><a class="header" href="#world-1">World</a></h2>
<pre><code class="language-rust  noplaypen">let mut world = World::new();

let empty_entity = world.add_entity(());
let single_component = world.add_entity((0u32,));
let multiple_components = world.add_entity((0u32, 1usize));</code></pre>
<p>⚠️ We have to use a single element tuple <code>(T,)</code> to add a single component entity.</p>
<h2 id="views-1"><a class="header" href="#views-1">Views</a></h2>
<pre><code class="language-rust  noplaypen">let world = World::new();

let (mut entities, mut u32s, mut usizes) = world
    .borrow::&lt;(EntitiesViewMut, ViewMut&lt;u32&gt;, ViewMut&lt;usize&gt;)&gt;()
    .unwrap();

let empty_entity = entities.add_entity((), ());
let single_component = entities.add_entity(&amp;mut u32s, 0);
let multiple_components = entities.add_entity((&amp;mut u32s, &amp;mut usizes), (0, 1));</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delete-entity"><a class="header" href="#delete-entity">Delete Entity</a></h1>
<p>Deleting an entity deletes it from the entities storage, while also deleting all its components.</p>
<h2 id="world-2"><a class="header" href="#world-2">World</a></h2>
<pre><code class="language-rust  noplaypen">let mut world = World::new();

let id = world.add_entity((0u32,));

world.delete_entity(id);</code></pre>
<h2 id="view"><a class="header" href="#view">View</a></h2>
<pre><code class="language-rust  noplaypen">let world = World::new();

let mut all_storages = world.borrow::&lt;AllStoragesViewMut&gt;().unwrap();

let id = all_storages.add_entity((0u32,));

all_storages.delete_entity(id);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-components"><a class="header" href="#add-components">Add Components</a></h1>
<p>An entity can have any number of components but only one in each storage.<br />
Adding another component of the same type will replace the existing one.</p>
<h2 id="world-3"><a class="header" href="#world-3">World</a></h2>
<pre><code class="language-rust  noplaypen">let mut world = World::new();

let id = world.add_entity(());

world.add_component(id, (0u32,));
world.add_component(id, (0u32, 1usize));</code></pre>
<p>⚠️ We have to use a single element tuple <code>(T,)</code> to add a single component.</p>
<h2 id="view-1"><a class="header" href="#view-1">View</a></h2>
<p>You'll notice that we use <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.EntitiesView.html"><code>EntitiesView</code></a> and not <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.EntitiesViewMut.html"><code>EntitiesViewMut</code></a> to add components.<br />
The entities storage is only used to check if the <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.EntityId.html"><code>EntityId</code></a> is alive.<br />
We could of course use <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.EntitiesViewMut.html"><code>EntitiesViewMut</code></a>, but exclusive access is not necessary.</p>
<p>If you don't need or want to check if the entity is alive, you can use the <a href="https://docs.rs/shipyard/0.5.0/shipyard/trait.AddComponent.html"><code>AddComponent::add_component_unchecked</code></a>.</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

let id = world
    .borrow::&lt;EntitiesViewMut&gt;()
    .unwrap()
    .add_entity((), ());

let (entities, mut u32s, mut usizes) = world
    .borrow::&lt;(EntitiesView, ViewMut&lt;u32&gt;, ViewMut&lt;usize&gt;)&gt;()
    .unwrap();

entities.add_component(id, &amp;mut u32s, 0);
entities.add_component(id, (&amp;mut u32s, &amp;mut usizes), (0, 1));
u32s.add_component_unchecked(id, 0);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remove-components"><a class="header" href="#remove-components">Remove Components</a></h1>
<p>Removing a component will take it out of the storage and return it.</p>
<h2 id="world-4"><a class="header" href="#world-4">World</a></h2>
<pre><code class="language-rust  noplaypen">let mut world = World::new();

let id = world.add_entity((0u32, 1usize));

world.remove::&lt;(u32,)&gt;(id);
world.remove::&lt;(u32, usize)&gt;(id);</code></pre>
<p>⚠️ We have to use a single element tuple <code>(T,)</code> to remove a single component entity.</p>
<h2 id="view-2"><a class="header" href="#view-2">View</a></h2>
<p>We have to import the <a href="https://docs.rs/shipyard/0.5.0/shipyard/trait.Remove.html"><code>Remove</code></a> trait for multiple components.</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

let (mut entities, mut u32s, mut usizes) = world
    .borrow::&lt;(EntitiesViewMut, ViewMut&lt;u32&gt;, ViewMut&lt;usize&gt;)&gt;()
    .unwrap();

let id = entities.add_entity((&amp;mut u32s, &amp;mut usizes), (0, 1));

u32s.remove(id);
(&amp;mut u32s, &amp;mut usizes).remove(id);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delete-components"><a class="header" href="#delete-components">Delete Components</a></h1>
<p>Deleting a component will erase it from the storage but will not return it.</p>
<h2 id="world-5"><a class="header" href="#world-5">World</a></h2>
<pre><code class="language-rust  noplaypen">let mut world = World::new();

let id = world.add_entity((0u32, 1usize));

world.delete_component::&lt;(u32,)&gt;(id);
world.delete_component::&lt;(u32, usize)&gt;(id);</code></pre>
<p>⚠️ We have to use a single element tuple <code>(T,)</code> to delete a single component entity.</p>
<h4 id="all-components"><a class="header" href="#all-components">All Components</a></h4>
<pre><code class="language-rust  noplaypen">let mut world = World::new();

let id = world.add_entity((0u32, 1usize));

world.strip(id);</code></pre>
<h2 id="view-3"><a class="header" href="#view-3">View</a></h2>
<p>We have to import the <a href="https://docs.rs/shipyard/0.5.0/shipyard/trait.Delete.html"><code>Delete</code></a> trait for multiple components.</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

let (mut entities, mut u32s, mut usizes) = world
    .borrow::&lt;(EntitiesViewMut, ViewMut&lt;u32&gt;, ViewMut&lt;usize&gt;)&gt;()
    .unwrap();

let id = entities.add_entity((&amp;mut u32s, &amp;mut usizes), (0, 1));

u32s.delete(id);
(&amp;mut u32s, &amp;mut usizes).delete(id);</code></pre>
<h4 id="all-components-1"><a class="header" href="#all-components-1">All Components</a></h4>
<pre><code class="language-rust  noplaypen">let world = World::new();

let mut all_storages = world.borrow::&lt;AllStoragesViewMut&gt;().unwrap();

let id = all_storages.add_entity((0u32, 1usize));

all_storages.strip(id);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-and-modify-components"><a class="header" href="#get-and-modify-components">Get and Modify Components</a></h1>
<p>To access or update components you can use <a href="https://docs.rs/shipyard/0.5.0/shipyard/trait.Get.html#tymethod.get"><code>Get::get</code></a>. It'll work with both shared and exclusive views.</p>
<pre><code class="language-rust  noplaypen">let mut world = World::new();

let id = world.add_entity((0u32, 1usize));

let (mut u32s, mut usizes) = world.borrow::&lt;(ViewMut&lt;u32&gt;, ViewMut&lt;usize&gt;)&gt;().unwrap();

*(&amp;mut usizes).get(id).unwrap() += 1;

let (mut i, j) = (&amp;mut u32s, &amp;usizes).get(id).unwrap();
*i += *j as u32;

u32s[id] += 1;</code></pre>
<p>When using a single view, if you are certain an entity has the desired component, you can access it via index.</p>
<h3 id="fast-get"><a class="header" href="#fast-get">Fast Get</a></h3>
<p>Using <a href="https://docs.rs/shipyard/0.5.0/shipyard/trait.Get.html#tymethod.get"><code>get</code></a> with <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.ViewMut.html"><code>&amp;mut ViewMut&lt;T&gt;</code></a> will return <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.Mut.html"><code>Mut&lt;T&gt;</code></a>. This struct helps fine track component modification.<br />
<a href="https://docs.rs/shipyard/0.5.0/shipyard/trait.FastGet.html#tymethod.fast_get"><code>FastGet::fast_get</code></a> can be used to opt out of this fine tracking and get back <code>&amp;mut T</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<p>Iteration is one of the most important features of an ECS.</p>
<p>In Shipyard this is achieved using <a href="https://docs.rs/shipyard/0.5.0/shipyard/trait.IntoIter.html#tymethod.iter"><code>IntoIter::iter</code></a> on views.</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

let (mut u32s, usizes) = world.borrow::&lt;(ViewMut&lt;u32&gt;, View&lt;usize&gt;)&gt;().unwrap();

for i in u32s.iter() {
    dbg!(i);
}

for (mut i, j) in (&amp;mut u32s, &amp;usizes).iter() {
    *i += *j as u32;
}</code></pre>
<p>You can use views in any order. However, using the same combination of views in different positions might yield components in a different order.<br />
You shouldn't expect specific ordering from Shipyard's iterators in general.</p>
<h4 id="with-id"><a class="header" href="#with-id">With Id</a></h4>
<p>You can ask an iterator to tell you which entity owns each component by using <a href="https://docs.rs/shipyard/0.5.0/shipyard/trait.IntoWithId.html#method.with_id"><code>WithId::with_id</code></a>:</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

let u32s = world.borrow::&lt;View&lt;u32&gt;&gt;().unwrap();

for (id, i) in u32s.iter().with_id() {
    println!(&quot;{} belongs to entity {:?}&quot;, i, id);
}</code></pre>
<h4 id="not"><a class="header" href="#not">Not</a></h4>
<p>It's possible to filter entities that don't have a certain component using <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.Not.html"><code>Not</code></a> by adding <code>!</code> in front of the view reference.</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

let (u32s, usizes) = world.borrow::&lt;(View&lt;u32&gt;, View&lt;usize&gt;)&gt;().unwrap();

for (i, _) in (&amp;u32s, !&amp;usizes).iter() {
    dbg!(i);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uniques"><a class="header" href="#uniques">Uniques</a></h1>
<p>Uniques (a.k.a. resources) are useful when you know there will only ever be a single instance of some component.<br />
In that case there is no need to attach the component to an entity. It also works well as global data while still being safe.</p>
<p>As opposed to other storages, uniques have to be initialized with <code>add_unique</code>. We can then access it with <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.UniqueView.html"><code>UniqueView</code></a> and <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.UniqueViewMut.html"><code>UniqueViewMut</code></a>.</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

world.add_unique(Camera::new()).unwrap();

world
    .run(|camera: UniqueView&lt;Camera&gt;| {
        // -- snip --
    })
    .unwrap();</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systems"><a class="header" href="#systems">Systems</a></h1>
<p>Systems are a great way to organize code.<br />
A function with views as arguments is all you need.</p>
<p>Here's an example:</p>
<pre><code class="language-rust  noplaypen">fn create_ints(mut entities: EntitiesViewMut, mut u32s: ViewMut&lt;u32&gt;) {
    // -- snip --
}</code></pre>
<p>We have a system, let's run it!</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

world.run(create_ints).unwrap();</code></pre>
<p>It also works with closures.</p>
<h3 id="passing-data-to-systems"><a class="header" href="#passing-data-to-systems">Passing Data to Systems</a></h3>
<p>The first argument doesn't have to be a view, you can pass any data, even references.</p>
<pre><code class="language-rust  noplaypen">fn in_acid(season: Season, positions: View&lt;Position&gt;, mut healths: ViewMut&lt;Health&gt;) {
    // -- snip --
}

let world = World::new();

world.run_with_data(in_acid, Season::Spring).unwrap();</code></pre>
<p>We call <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.World.html#method.run_with_data"><code>run_with_data</code></a> instead of <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.World.html#method.run"><code>run</code></a> when we want to pass data to a system.</p>
<p>If you want to pass multiple variables, you can use a tuple.</p>
<pre><code class="language-rust  noplaypen">fn in_acid(
    (season, precipitation): (Season, Precipitation),
    positions: View&lt;Position&gt;,
    mut healths: ViewMut&lt;Health&gt;,
) {
    // -- snip --
}

let world = World::new();

world
    .run_with_data(in_acid, (Season::Spring, Precipitation(0.1)))
    .unwrap();</code></pre>
<h3 id="workloads"><a class="header" href="#workloads">Workloads</a></h3>
<p>A workload is a named group of systems.</p>
<pre><code class="language-rust  noplaypen">fn create_ints(mut entities: EntitiesViewMut, mut u32s: ViewMut&lt;u32&gt;) {
    // -- snip --
}

fn delete_ints(mut u32s: ViewMut&lt;u32&gt;) {
    // -- snip --
}

let world = World::new();

Workload::builder(&quot;Int cycle&quot;)
    .with_system(&amp;create_ints)
    .with_system(&amp;delete_ints)
    .add_to_world(&amp;world)
    .unwrap();

world.run_workload(&quot;Int cycle&quot;).unwrap();</code></pre>
<p>Workloads are stored in the <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.World.html"><code>World</code></a>, ready to be run again and again.<br />
They don't take up much memory so even if you make a few with similar systems it's not a problem.</p>
<p>Workloads will run their systems first to last or at the same time when possible. We call this <em>outer-parallelism</em>, you can learn more about it in <a href="fundamentals/../going-further/parallelism.html">this chapter</a>.</p>
<h4 id="workload-nesting"><a class="header" href="#workload-nesting">Workload Nesting</a></h4>
<p>You can also add a workload to another and build your execution logic brick by brick.</p>
<pre><code class="language-rust  noplaypen">struct Dead&lt;T&gt;(core::marker::PhantomData&lt;T&gt;);

fn increment(mut u32s: ViewMut&lt;u32&gt;) {
    for mut i in (&amp;mut u32s).iter() {
        *i += 1;
    }
}

fn flag_deleted_u32s(u32s: View&lt;u32&gt;, mut deads: ViewMut&lt;Dead&lt;u32&gt;&gt;) {
    for (id, i) in u32s.iter().with_id() {
        if *i &gt; 100 {
            deads.add_component_unchecked(id, Dead(core::marker::PhantomData));
        }
    }
}

fn clear_deleted_u32s(mut all_storages: AllStoragesViewMut) {
    all_storages.delete_any::&lt;SparseSet&lt;Dead&lt;u32&gt;&gt;&gt;();
}

let world = World::new();

Workload::builder(&quot;Filter u32&quot;)
    .with_system(&amp;flag_deleted_u32s)
    .with_system(&amp;clear_deleted_u32s)
    .add_to_world(&amp;world)
    .unwrap();

Workload::builder(&quot;Loop&quot;)
    .with_system(&amp;increment)
    .with_workload(&quot;Filter u32&quot;)
    .add_to_world(&amp;world)
    .unwrap();

world.run_workload(&quot;Loop&quot;).unwrap();</code></pre>
<hr />
<p>Congratulations, you made it to the end of the fundamentals!<br />
The next section will take you under the hood to learn how to get the most out of Shipyard.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="going-further"><a class="header" href="#going-further">Going Further</a></h1>
<p>This section covers more advanced topics. Topics include parallelism, and how everything behaves so you can avoid surprises.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sparse-set"><a class="header" href="#sparse-set">Sparse Set</a></h1>
<p><a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.SparseSet.html"><code>SparseSet</code></a> is Shipyard's default storage. This chapter explains the basics of how it works, the actual implementation is more optimized both in term of speed and memory.</p>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<p><a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.SparseSet.html"><code>SparseSet</code></a> is made of three arrays:</p>
<ul>
<li><code>sparse</code> contains indices to the <code>dense</code> and <code>data</code> arrays</li>
<li><code>dense</code> contains <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.EntityId.html"><code>EntityId</code></a></li>
<li><code>data</code> contains the actual components</li>
</ul>
<p><code>dense</code> and <code>data</code> always have the same length, the number of components present in the storage.<br />
<code>sparse</code> on the other hand can be as big as the total number of entities created.</p>
<p>Let's look at an example:</p>
<pre><code class="language-rust  noplaypen">let mut world = World::new();

let entity0 = world.add_entity((0u32,));
let entity1 = world.add_entity((10.0f32,));
let entity2 = world.add_entity((20u32,));</code></pre>
<p>The <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.World.html"><code>World</code></a> starts out empty, when we add <code>0u32</code> a <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.SparseSet.html"><code>SparseSet&lt;u32&gt;</code></a> will be generated.</p>
<p>At the end of the example we have:</p>
<pre><code class="language-txt">SparseSet&lt;u32&gt;:
    sparse: [0, dead, 1]
    dense:  [0, 2]
    data:   [0, 20]

SparseSet&lt;f32&gt;:
    sparse: [dead, 0]
    dense:  [1]
    data:   [10.0]
</code></pre>
<p>You can see that <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.SparseSet.html"><code>SparseSet&lt;u32&gt;</code></a>'s <code>sparse</code> contains three elements but <code>dense</code> does not.<br />
Note also that both <code>sparse</code> don't contains the same number of elements. As far as <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.SparseSet.html"><code>SparseSet&lt;f32&gt;</code></a> knowns <code>entity2</code> might not exist.</p>
<h3 id="removal"><a class="header" href="#removal">Removal</a></h3>
<p>Removing is done by swap removing from both <code>dense</code> and <code>data</code> and updating <code>sparse</code> in consequence.</p>
<p>Continuing the previous example if we call:</p>
<pre><code class="language-rust  noplaypen">world.remove::&lt;(u32,)&gt;(entity0);</code></pre>
<p>The internal representation now looks like this:</p>
<pre><code class="language-txt">sparse: [dead, dead, 0]
dense: [2]
data: [20]
</code></pre>
<p><code>dense</code> and <code>data</code> shifted to the left, <code>sparse</code>'s first element is now dead and the third element is now <code>0</code> to follow <code>dense</code>'s shift.</p>
<h3 id="iteration"><a class="header" href="#iteration">Iteration</a></h3>
<p>Iterating one or several <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.SparseSet.html"><code>SparseSet</code></a> is different. With a single <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.SparseSet.html"><code>SparseSet</code></a> it's as simple as iterating <code>data</code>.<br />
To iterate multiple <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.SparseSet.html"><code>SparseSet</code></a>s the smallest will be chosen as &quot;lead&quot;. We then iterate its <code>dense</code> array and for each entity we check all the other <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.SparseSet.html"><code>SparseSet</code></a>s to see if they also contain a component for this entity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parallelism"><a class="header" href="#parallelism">Parallelism</a></h1>
<p>By late 90s - early 2000s, CPUs started to get too close to the physical limitation of transistors and manufacturers couldn't &quot;just&quot; make their product faster. The solution: more cores.</p>
<p>Nowadays almost all devices come with multiple cores, it would be a shame to use just one.</p>
<p>In ECS there's two big ways to split work across cores: running systems on separate threads or using a parallel iterator, we call these two methods &quot;outer-parallelism&quot; and &quot;inner-parallelism,&quot; respectively.</p>
<h3 id="outer-parallelism"><a class="header" href="#outer-parallelism">Outer-parallelism</a></h3>
<p>We'll start by the simplest one to use. So simple that there's nothing to do, workloads handle all the work for you. We even almost used multiple threads in the <a href="going-further/../fundamentals/systems.html">Systems chapter</a>.</p>
<p>As long as the &quot;parallel&quot; feature is set (enabled by default) workloads will try to execute systems as much in parallel as possible. There is a set of rules that defines the &quot;possible&quot;:</p>
<ul>
<li>Systems accessing <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.AllStorages.html"><code>AllStorages</code></a> stop all threading.</li>
<li>There can't be any other access during an exclusive access, so <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.ViewMut.html"><code>ViewMut&lt;T&gt;</code></a> will block <code>T</code> threading.</li>
</ul>
<p>When you make a workload, all systems in it will be checked and batches (groups of systems that don't conflict) will be created.<br />
<a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.WorkloadBuilder.html#method.add_to_world"><code>add_to_world</code></a> returns information about these batches and why each system didn't get into the previous batch.</p>
<h3 id="inner-parallelism"><a class="header" href="#inner-parallelism">Inner-parallelism</a></h3>
<p>While parallel iterators does require us to modify our code, it's just a matter of using <code>par_iter</code> instead of <code>iter</code>.<br />
Don't forget to import rayon. <a href="https://docs.rs/shipyard/0.5.0/shipyard/trait.IntoIter.html#tymethod.par_iter"><code>par_iter</code></a> returns a <a href="https://docs.rs/rayon/0.5.0/rayon/iter/trait.ParallelIterator.html"><code>ParallelIterator</code></a>.</p>
<p>Example:</p>
<pre><code class="language-rust  noplaypen">use rayon::prelude::*;

fn many_u32s(mut u32s: ViewMut&lt;u32&gt;) {
    u32s.par_iter().for_each(|i| {
        // -- snip --
    });
}</code></pre>
<p>Don't replace all your <a href="https://docs.rs/shipyard/0.5.0/shipyard/trait.IntoIter.html#tymethod.iter"><code>iter</code></a> method calls just yet, however! Using a parallel iterator comes with an upfront overhead cost. It will only exceed the speed of its sequential counterpart on storages large enough to make up for the overhead cost in improved processing efficiency.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-and-sync-components"><a class="header" href="#send-and-sync-components"><code>!Send</code> and <code>!Sync</code> Components</a></h1>
<p><a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.World.html"><code>World</code></a> can store <code>!Send</code> and/or <code>!Sync</code> components once the <code>thread_local</code> feature is set but they come with limitations:</p>
<ul>
<li><code>!Send</code> storages can only be added in <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.World.html"><code>World</code></a>'s thread.</li>
<li><code>Send + !Sync</code> components can only be accessed from one thread at a time.</li>
<li><code>!Send + Sync</code> components can only be accessed immutably from other threads.</li>
<li><code>!Send + !Sync</code> components can only be accessed in the thread they were added in.</li>
</ul>
<p>These storages are accessed with <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.NonSend.html"><code>NonSend</code></a>, <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.NonSync.html"><code>NonSync</code></a> and <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.NonSendSync.html"><code>NonSendSync</code></a>, for example:</p>
<pre><code class="language-rust  noplaypen">fn run(rcs_usize: NonSendSync&lt;View&lt;Rc&lt;usize&gt;&gt;&gt;, rc_u32: NonSendSync&lt;UniqueView&lt;Rc&lt;u32&gt;&gt;&gt;) {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h1>
<p>List of small information to get the most out of Shipyard.</p>
<h3 id="for_each"><a class="header" href="#for_each"><code>for_each</code></a></h3>
<p><code>for ... in</code> desugars to calling <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next"><code>next</code></a> repeatedly, the compiler can sometimes optimize it very well.<br />
If you don't want to take any chance prefer calling <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.for_each"><code>for_each</code></a> instead.</p>
<h3 id="borrow--run-in-a-loop"><a class="header" href="#borrow--run-in-a-loop"><code>borrow</code> / <code>run</code> in a loop</a></h3>
<p>While borrowing storages is quite cheap, doing so in a loop is generally a bad idea.<br />
Prefer moving the loop inside <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.World.html#method.run"><code>run</code></a> and move <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.World.html#method.borrow"><code>borrow</code></a>'s call outside the loop.</p>
<h3 id="bulk_add_entity"><a class="header" href="#bulk_add_entity"><code>bulk_add_entity</code></a></h3>
<p>When creating many entities at the same time remember to call <a href="https://docs.rs/shipyard/0.5.0/shipyard/struct.World.html#method.bulk_add_entity"><code>bulk_add_entity</code></a> if possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipes"><a class="header" href="#recipes">Recipes</a></h1>
<p>Cool patterns you may be interested in.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-an-entity-hierarchy-with-shipyard"><a class="header" href="#building-an-entity-hierarchy-with-shipyard">Building an Entity Hierarchy with Shipyard</a></h1>
<p>Hierarchies are a very commonly used organizational structure in game development. An important example is a transform hierarchy: child entities move along with their parents.</p>
<p>How can we build such a hierarchy of entities in shipyard?</p>
<p>One method is to use a secondary data structure which represents the hierarchy.</p>
<p>But an ECS already has all the means to store data: components. So let's use them!</p>
<p>Below you won't find a ready-to-use solution, rather some hints on how to start with your own hierarchy implementation, tailored to your requirements.</p>
<h2 id="parents-and-children"><a class="header" href="#parents-and-children">Parents and Children</a></h2>
<p>Think about the different roles an entity can take in a hierarchy. It can be:</p>
<ul>
<li>a parent (root node),</li>
<li>a parent and a child (intermediate node),</li>
<li>a child (leaf node).</li>
</ul>
<p>From this we can derive two simple, composable component types:</p>
<p>A <code>Parent</code> component stores the number of its children and the first child:</p>
<pre><code class="language-rust  noplaypen">struct Parent {
    num_children: usize,
    first_child: EntityId,
}</code></pre>
<p>A <code>Child</code> component links to its parent as well as neighbor siblings:</p>
<pre><code class="language-rust  noplaypen">struct Child {
    parent: EntityId,
    prev: EntityId,
    next: EntityId,
}</code></pre>
<p>As you can see, we simply store <code>EntityId</code>s to refer to other entities inside a component.</p>
<p>Note that <code>Option</code>s are completely avoided by making the sibling chain circular:</p>
<ul>
<li>Last child's <code>next</code> points to the first child.</li>
<li>First child's <code>prev</code> points to the last child.</li>
</ul>
<p>Our entire hierarchy structure resides only in <code>Parent</code> and <code>Child</code> components – nice!</p>
<p>But it'd be a hassle to create them manually each time you want to insert an entity into the tree.</p>
<h2 id="lets-make-it-convenient"><a class="header" href="#lets-make-it-convenient">Let's make it convenient</a></h2>
<p>We begin with two useful methods in a trait declaration:</p>
<pre><code class="language-rust  noplaypen">trait Hierarchy {
    // Removes the child status of an entity.
    fn detach(&amp;mut self, id: EntityId);

    // Attaches an entity as a child to a given parent entity.
    fn attach(&amp;mut self, id: EntityId, parent: EntityId);
}</code></pre>
<p>With these, you'll be able to not only insert new entities into the tree but also move a whole subtree – a child with all its descendants – to another parent.</p>
<p>Since we need access to <code>EntitiesViewMut</code> as well as our hierarchy component storages, we implement the <code>Hierarchy</code> trait for the type <code>(EntitiesViewMut&lt;'_&gt;, ViewMut&lt;'_, Parent&gt;, ViewMut&lt;'_, Child&gt;)</code>.</p>
<pre><code class="language-rust  noplaypen">fn detach(&amp;mut self, id: EntityId) {
    let (_, parents, children) = self;
    // remove the Child component - if nonexistent, do nothing
    if let Some(child) = children.remove(id) {
        // retrieve and update Parent component from ancestor
        let parent = &amp;mut parents[child.parent];
        parent.num_children -= 1;

        if parent.num_children == 0 {
            // if the number of children is zero, the Parent component must be removed
            parents.remove(child.parent);
        } else {
            // the ancestor still has children, and we have to change some linking
            // check if we have to change first_child
            if parent.first_child == id {
                parent.first_child = child.next;
            }
            // remove the detached child from the sibling chain
            children[child.prev].next = child.next;
            children[child.next].prev = child.prev;
        }
    }
}</code></pre>
<p>Before we move on to <code>attach</code>, let's make some observations.</p>
<p>We use indexing on <code>parents</code> and <code>children</code> but if the entity doesn't have the component it'll <code>unwrap</code>.</p>
<p>We don't have to worry as long as we only use the methods in our <code>Hierarchy</code> trait.</p>
<p>If you accidentally delete hierarchy components in other places without changing the linking, things will go fatally wrong. If you want to catch these errors you might want to use <code>get</code> and handle the error (for example with <code>expect</code>).</p>
<p><code>attach</code> looks like this:</p>
<pre><code class="language-rust  noplaypen">fn attach(&amp;mut self, id: EntityId, parent: EntityId) {
    // the entity we want to attach might already be attached to another parent
    self.detach(id);

    let (entities, parents, children) = self;

    // either the designated parent already has a Parent component – and thus one or more children
    if let Ok(p) = parents.get(parent) {
        // increase the parent's children counter
        p.num_children += 1;

        // get the ids of the new previous and next siblings of our new child
        let prev = children[p.first_child].prev;
        let next = p.first_child;

        // change the linking
        children[prev].next = id;
        children[next].prev = id;

        // add the Child component to the new entity
        entities.add_component(id, children, Child { parent, prev, next });
    } else {
        // in this case our designated parent is missing a Parent component
        // we don't need to change any links, just insert both components
        entities.add_component(
            id,
            children,
            Child {
                parent,
                prev: id,
                next: id,
            },
        );
        entities.add_component(
            parent,
            parents,
            Parent {
                num_children: 1,
                first_child: id,
            },
        );
    }
}</code></pre>
<p>We can now add another handy method to our trait:</p>
<pre><code class="language-rust  noplaypen">// Creates a new entity and attaches it to the given parent.
fn attach_new(&amp;mut self, parent: EntityId) -&gt; EntityId;`</code></pre>
<pre><code class="language-rust  noplaypen">fn attach_new(&amp;mut self, parent: EntityId) -&gt; EntityId {
    let id = self.0.add_entity((), ());
    self.attach(id, parent);
    id
}</code></pre>
<p>And lastly a simple usage example:</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

let mut hierarchy = world.borrow::&lt;(EntitiesViewMut, ViewMut&lt;Parent&gt;, ViewMut&lt;Child&gt;)&gt;().unwrap();

let root1 = hierarchy.0.add_entity((), ());
let root2 = hierarchy.0.add_entity((), ());

let e1 = hierarchy.attach_new(root1);
let _e2 = hierarchy.attach_new(e1);
let e3 = hierarchy.attach_new(e1);
let _e4 = hierarchy.attach_new(e3);

hierarchy.attach(e3, root2);</code></pre>
<h2 id="traversing-the-hierarchy"><a class="header" href="#traversing-the-hierarchy">Traversing the hierarchy</a></h2>
<p>There are different ways the hierarchy can be queried.</p>
<p>For example, we may want to know the parent of a given entity. Doing this is simply done by inspecting its child component - if there is one.</p>
<p>However, sometimes you might need</p>
<ul>
<li>all children,</li>
<li>all ancestors,</li>
<li>or all descendants of a given entity.</li>
</ul>
<p>A perfect use case for iterators! An iterator has to implement the <code>next</code> method from the <code>Iterator</code> trait.</p>
<p>We start with a <code>ChildrenIter</code>, which is pretty straightforward:</p>
<pre><code class="language-rust  noplaypen">struct ChildrenIter&lt;C&gt; {
    get_child: C,
    cursor: (EntityId, usize),
}

impl&lt;'a, C&gt; Iterator for ChildrenIter&lt;C&gt;
where
    C: Get&lt;Out = &amp;'a Child&gt; + Copy,
{
    type Item = EntityId;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.cursor.1 &gt; 0 {
            self.cursor.1 -= 1;
            let ret = self.cursor.0;
            self.cursor.0 = self.get_child.get(self.cursor.0).unwrap().next;
            Some(ret)
        } else {
            None
        }
    }
}</code></pre>
<p>Note that we don't implement <code>Iterator</code> for <code>ViewMut&lt;Child&gt;</code> directly, but for a type that implements the <code>GetComponent</code> trait. This way, our iterator can be used with <code>View</code> as well as <code>ViewMut</code>.</p>
<p>The next one is the <code>AncestorIter</code>:</p>
<pre><code class="language-rust  noplaypen">struct AncestorIter&lt;C&gt; {
    get_child: C,
    cursor: EntityId,
}

impl&lt;'a, C&gt; Iterator for AncestorIter&lt;C&gt;
where
    C: Get&lt;Out = &amp;'a Child&gt; + Copy,
{
    type Item = EntityId;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.get_child.get(self.cursor).ok().map(|child| {
            self.cursor = child.parent;
            child.parent
        })
    }
}</code></pre>
<p>Easy.</p>
<p><code>DescendantIter</code> will be a bit more complicated. We choose to implement a depth-first variant using recursion.</p>
<p>It is based on the code for the <code>ChildrenIter</code> but comes with an additional stack to keep track of the current level the cursor is in:</p>
<ul>
<li>Push a new level to the stack if we encounter a <code>Parent</code> component.</li>
<li>Pop the last level from the stack whenever we run out of siblings, then carry on where we left off.</li>
</ul>
<pre><code class="language-rust  noplaypen">struct DescendantsIter&lt;P, C&gt; {
    get_parent: P,
    get_child: C,
    cursors: Vec&lt;(EntityId, usize)&gt;,
}

impl&lt;'a, P, C&gt; Iterator for DescendantsIter&lt;P, C&gt;
where
    P: Get&lt;Out = &amp;'a Parent&gt; + Copy,
    C: Get&lt;Out = &amp;'a Child&gt; + Copy,
{
    type Item = EntityId;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if let Some(cursor) = self.cursors.last_mut() {
            if cursor.1 &gt; 0 {
                cursor.1 -= 1;
                let ret = cursor.0;
                cursor.0 = self.get_child.get(cursor.0).unwrap().next;
                if let Ok(parent) = self.get_parent.get(ret) {
                    self.cursors.push((parent.first_child, parent.num_children));
                }
                Some(ret)
            } else {
                self.cursors.pop();
                self.next()
            }
        } else {
            None
        }
    }
}</code></pre>
<p>What we still need to do is to implement a simple trait with methods that return nicely initialized <code>*Iter</code> structs for us:</p>
<pre><code class="language-rust  noplaypen">trait HierarchyIter&lt;'a, P, C&gt; {
    fn ancestors(&amp;self, id: EntityId) -&gt; AncestorIter&lt;C&gt;;
    fn children(&amp;self, id: EntityId) -&gt; ChildrenIter&lt;C&gt;;
    fn descendants(&amp;self, id: EntityId) -&gt; DescendantsIter&lt;P, C&gt;;
}

impl&lt;'a, P, C&gt; HierarchyIter&lt;'a, P, C&gt; for (P, C)
where
    P: Get&lt;Out = &amp;'a Parent&gt; + Copy,
    C: Get&lt;Out = &amp;'a Child&gt; + Copy,
{
    fn ancestors(&amp;self, id: EntityId) -&gt; AncestorIter&lt;C&gt; {
        let (_, children) = self;

        AncestorIter {
            get_child: *children,
            cursor: id,
        }
    }

    fn children(&amp;self, id: EntityId) -&gt; ChildrenIter&lt;C&gt; {
        let (parents, children) = self;

        ChildrenIter {
            get_child: *children,
            cursor: parents
                .get(id)
                .map_or((id, 0), |parent| (parent.first_child, parent.num_children)),
        }
    }

    fn descendants(&amp;self, id: EntityId) -&gt; DescendantsIter&lt;P, C&gt; {
        let (parents, children) = self;

        DescendantsIter {
            get_parent: *parents,
            get_child: *children,
            cursors: parents.get(id).map_or_else(
                |_| Vec::new(),
                |parent| vec![(parent.first_child, parent.num_children)],
            ),
        }
    }
}</code></pre>
<p>Cool. Let's extend the former usage example into a little test.</p>
<pre><code class="language-rust  noplaypen">#[test]
fn test_hierarchy() {
    let world = World::new();

    let mut hierarchy = world.borrow::&lt;(EntitiesViewMut, ViewMut&lt;Parent&gt;, ViewMut&lt;Child&gt;)&gt;().unwrap();

    let root1 = hierarchy.0.add_entity((), ());
    let root2 = hierarchy.0.add_entity((), ());

    let e1 = hierarchy.attach_new(root1);
    let e2 = hierarchy.attach_new(e1);
    let e3 = hierarchy.attach_new(e1);
    let e4 = hierarchy.attach_new(e3);

    hierarchy.attach(e3, root2);

    let e5 = hierarchy.attach_new(e3);

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .children(e3)
        .eq([e4, e5].iter().cloned()));

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .ancestors(e4)
        .eq([e3, root2].iter().cloned()));

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .descendants(root1)
        .eq([e1, e2].iter().cloned()));

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .descendants(root2)
        .eq([e3, e4, e5].iter().cloned()));
}</code></pre>
<h2 id="removing-entities-from-the-hierarchy"><a class="header" href="#removing-entities-from-the-hierarchy">Removing entities from the hierarchy</a></h2>
<p>Removing an entity from the hierarchy means removing its <code>Parent</code> and <code>Child</code> components.</p>
<p>To remove an entity's <code>Child</code> component, we can simply reuse <code>detach</code>. Removing its <code>Parent</code> component must be done with caution. This entity's children now become orphans – we have to detach them as well.</p>
<p>Both methods can be added to our <code>Hierarchy</code> trait:</p>
<pre><code class="language-rust  noplaypen">fn remove(&amp;mut self, id: EntityId) {
    self.detach(id);

    let children = (&amp;self.1, &amp;self.2).children(id).collect::&lt;Vec&lt;_&gt;&gt;();
    for child_id in children {
        self.detach(child_id);
    }
    self.1.remove(id);
}</code></pre>
<p>A method that removes a whole subtree is easy to write by making use of recursion again:</p>
<pre><code class="language-rust  noplaypen">fn remove_all(&amp;mut self, id: EntityId) {
    let (_, parents, children) = self;

    for child_id in (&amp;*parents, &amp;*children).children(id).collect::&lt;Vec&lt;_&gt;&gt;() {
        self.remove_all(child_id);
    }
    self.remove(id);
}</code></pre>
<p>That's it! We can now add the following code to the end of our test from the last chapter:</p>
<pre><code class="language-rust  noplaypen">hierarchy.detach(e1);

assert!((&amp;hierarchy.1, &amp;hierarchy.2).descendants(root1).eq(None));
assert!((&amp;hierarchy.1, &amp;hierarchy.2).ancestors(e1).eq(None));
assert!((&amp;hierarchy.1, &amp;hierarchy.2).children(e1).eq([e2].iter().cloned()));

hierarchy.remove(e1);

assert!((&amp;hierarchy.1, &amp;hierarchy.2).children(e1).eq(None));

hierarchy.remove_all(root2);

assert!((&amp;hierarchy.1, &amp;hierarchy.2).descendants(root2).eq(None));
assert!((&amp;hierarchy.1, &amp;hierarchy.2).descendants(e3).eq(None));
assert!((&amp;hierarchy.1, &amp;hierarchy.2).ancestors(e5).eq(None));</code></pre>
<h2 id="sorting"><a class="header" href="#sorting">Sorting</a></h2>
<p>The order between siblings may or may not play a role in your project.</p>
<p>However, a simple sorting for children can be done in two steps:</p>
<ul>
<li>Collect all children into a <code>Vec</code> and sort it.</li>
<li>Adjust the linking in the <code>Child</code> components according to the sorted list.</li>
</ul>
<p>We can add this method to the <code>Hierarchy</code> trait:</p>
<pre><code class="language-rust  noplaypen">fn sort_children_by&lt;F&gt;(&amp;mut self, id: EntityId, compare: F)
where
    F: FnMut(&amp;EntityId, &amp;EntityId) -&gt; std::cmp::Ordering,
{
    let (_, parents, children_storage) = self;

    let mut children = (&amp;*parents, &amp;*children_storage)
        .children(id)
        .collect::&lt;Vec&lt;EntityId&gt;&gt;();
    if children.len() &gt; 1 {
        children.sort_by(compare);
        // set first_child in Parent component
        parents[id].first_child = children[0];
        // loop through children and relink them
        for i in 0..children.len() - 1 {
            children_storage[children[i]].next = children[i + 1];
            children_storage[children[i + 1]].prev = children[i];
        }
        children_storage[children[0]].prev = *children.last().unwrap();
        children_storage[*children.last().unwrap()].next = children[0];
    }
}</code></pre>
<p>Again a small test demonstrates the usage:</p>
<pre><code class="language-rust  noplaypen">#[test]
fn test_sorting() {
    let world = World::new();

    let (mut hierarchy, mut usizes) = world.borrow::&lt;(
        (EntitiesViewMut, ViewMut&lt;Parent&gt;, ViewMut&lt;Child&gt;),
        ViewMut&lt;usize&gt;,
    )&gt;().unwrap();

    let root = hierarchy.0.add_entity((), ());

    let e0 = hierarchy.attach_new(root);
    let e1 = hierarchy.attach_new(root);
    let e2 = hierarchy.attach_new(root);
    let e3 = hierarchy.attach_new(root);
    let e4 = hierarchy.attach_new(root);

    hierarchy.0.add_component(e0, &amp;mut usizes, 7);
    hierarchy.0.add_component(e1, &amp;mut usizes, 5);
    hierarchy.0.add_component(e2, &amp;mut usizes, 6);
    hierarchy.0.add_component(e3, &amp;mut usizes, 1);
    hierarchy.0.add_component(e4, &amp;mut usizes, 3);

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .children(root)
        .eq([e0, e1, e2, e3, e4].iter().cloned()));

    hierarchy.sort_children_by(root, |a, b| usizes[*a].cmp(&amp;usizes[*b]));

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .children(root)
        .eq([e3, e4, e1, e2, e0].iter().cloned()));
}</code></pre>
<h2 id="do-it-yourself"><a class="header" href="#do-it-yourself">Do it yourself!</a></h2>
<p>We recommend that you build your own hierarchy system fitted to your specific needs. In deviation of the above code examples you may want:</p>
<ul>
<li>a single hierarchy component instead of two,</li>
<li>breadth-first instead of depth-first traversal,</li>
<li>different sorting methods,</li>
<li>etc.</li>
</ul>
<h2 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h2>
<p>These notes are based on ideas presented in a highly recommended article by skypjack: <a href="https://skypjack.github.io/2019-06-25-ecs-baf-part-4/">ECS back and forth</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>If you're working with <a href="https://github.com/seed-rs/seed">Seed</a>, @MartinKavik ported the bunny demo to it. You can find the source <a href="https://github.com/seed-rs/seed/tree/master/examples/bunnies">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>0.4 comes with a few big changes, this chapter aims to facilitate the transition.</p>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<p>Let's start small, prelude and internal no longer exist, you just have to replace all <code>shipyard::prelude</code> and <code>shipyard::internal</code> by <code>shipyard</code>.</p>
<h2 id="systems-1"><a class="header" href="#systems-1">Systems</a></h2>
<p>Following <a href="https://github.com/leudz/shipyard/issues/75">an issue</a> opened by <a href="https://github.com/cart">@cart</a>, systems will become functions instead of an instance of the <code>System</code> trait.</p>
<p>To make this work, borrowing is now done with the actual types you get when you borrow a storage instead of using references.</p>
<p>In 0.3:</p>
<pre><code class="language-rust  noplaypen">struct MySystem;
impl&lt;'sys&gt; System&lt;'sys&gt; for MySystem {
    type Data = (
        EntitiesMut,
        &amp;mut usize,
    );
    fn run((mut entities, mut usizes): &lt;Self::Data as SystemData&lt;'sys&gt;&gt;::View) {}
}

// or with the macro

#[system(MySystem)]
fn run(mut entities: &amp;mut Entities, mut usizes: &amp;mut usize) {}</code></pre>
<p>In 0.4:</p>
<pre><code class="language-rust  noplaypen">fn my_system(mut entities: EntitiesViewMut, mut usizes: ViewMut&lt;usize&gt;) {}</code></pre>
<p>This change also affects <code>run</code> and <code>borrow</code>.<br />
<code>World::run_system</code> is no longer needed and you can run systems with <code>run</code> directly.</p>
<pre><code class="language-rust  noplaypen">world.run(my_system);

// and closures still work

world.run(|mut entities: EntitiesViewMut, mut usizes: ViewMut&lt;usize&gt;| {});</code></pre>
<p><code>run</code> has the same return type as the system or closure and it doesn't require any tuple most of the time.</p>
<p>Here's the complete list:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">0.3</th><th style="text-align: center">0.4</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>AllStorages</code> / <code>&amp;mut AllStorages</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.AllStoragesViewMut.html"><code>AllStoragesViewMut</code></a></td></tr>
<tr><td style="text-align: center"><code>Entities</code> / <code>&amp;Entities</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.EntitiesView.html"><code>EntitiesView</code></a></td></tr>
<tr><td style="text-align: center"><code>EntitiesMut</code> / <code>&amp;mut Entities</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.EntitiesViewMut.html"><code>EntitiesViewMut</code></a></td></tr>
<tr><td style="text-align: center"><code>&amp;T</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.View.html"><code>View&lt;T&gt;</code></a></td></tr>
<tr><td style="text-align: center"><code>&amp;mut T</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.ViewMut.html"><code>ViewMut&lt;T&gt;</code></a></td></tr>
<tr><td style="text-align: center"><code>ThreadPool</code> / <code>&amp;ThreadPool</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.ThreadPoolView.html"><code>ThreadPoolView</code></a></td></tr>
<tr><td style="text-align: center"><code>Unique&lt;&amp;T&gt;</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.UniqueView.html"><code>UniqueView&lt;T&gt;</code></a></td></tr>
<tr><td style="text-align: center"><code>Unique&lt;&amp;mut T&gt;</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.UniqueViewMut.html"><code>UniqueViewMut&lt;T&gt;</code></a></td></tr>
<tr><td style="text-align: center"><code>NonSend&lt;&amp;T&gt;</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSend.html"><code>NonSend&lt;View&lt;T&gt;&gt;</code></a></td></tr>
<tr><td style="text-align: center"><code>NonSend&lt;&amp;mut T&gt;</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSend.html"><code>NonSend&lt;ViewMut&lt;T&gt;&gt;</code></a></td></tr>
<tr><td style="text-align: center"><code>Unique&lt;NonSend&lt;&amp;T&gt;&gt;</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSend.html"><code>NonSend&lt;UniqueView&lt;T&gt;&gt;</code></a></td></tr>
<tr><td style="text-align: center"><code>Unique&lt;NonSend&lt;&amp;mut T&gt;&gt;</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSend.html"><code>NonSend&lt;UniqueViewMut&lt;T&gt;&gt;</code></a></td></tr>
<tr><td style="text-align: center"><code>FakeBorrow&lt;T&gt;</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.FakeBorrow.html"><code>FakeBorrow&lt;T&gt;</code></a></td></tr>
</tbody></table>
</div>
<p><a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSync.html"><code>NonSync</code></a> and <a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSendSync.html"><code>NonSendSync</code></a> follow the same pattern as <code>NonSend</code>.</p>
<h2 id="macro"><a class="header" href="#macro">Macro</a></h2>
<p>The system proc macro doesn't exist anymore. With the new system design the advantage it provides are not great enough to justify it.</p>
<h2 id="workloads-1"><a class="header" href="#workloads-1">Workloads</a></h2>
<h3 id="the-ugly"><a class="header" href="#the-ugly">The ugly</a></h3>
<p>Workloads are the only one suffering a downgrade. You'll have to give all systems twice to the function plus a few things.</p>
<p>In 0.3:</p>
<pre><code class="language-rust  noplaypen">world.add_workload&lt;(Sys1, Sys2), _&gt;(&quot;Workload1&quot;);</code></pre>
<p>In 0.4:</p>
<pre><code class="language-rust  noplaypen">world
    .add_workload(&quot;Workload1&quot;)
    .with_system((
        |world: &amp;World| world.try_run(sys1),
        sys1
    ))
    .with_system((
        |world: &amp;World| world.try_run(sys2),
        sys2
    ))
    .build();

// with a macro

world
    .add_workload(&quot;Workload1&quot;)
    .with_system(system!(sys1))
    .with_system(system!(sys2))
    .build();</code></pre>
<p>⚠️ The two arguments are wrapped in a tuple.</p>
<p>This repetition will disappear someday but I don't expect it to be soon.<br />
You don't have to use a closure, any function with <code>&amp;World</code> as argument and returning <code>Result&lt;(), shipyard::error::Run&gt;</code> are valid.<br />
It's very important to pass the same function twice, the workload might always error if this isn't the case.</p>
<h3 id="the-good"><a class="header" href="#the-good">The good</a></h3>
<p>Workloads don't come with only a downgrade. You can now return errors from systems inside workloads.</p>
<pre><code class="language-rust  noplaypen">#[derive(Debug)]
struct TerribleError;

impl Display for TerribleError {
    fn fmt(&amp;self, fmt: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), core::fmt::Error&gt; {
        Debug::fmt(self, fmt)
    }
}
impl Error for TerribleError {}

fn my_sys(mut entities: EntitiesViewMut) -&gt; Result&lt;(), TerribleError&gt; {
    Err(TerribleError)
}

fn main() {
    use shipyard::error::{Run, RunWorkload};

    let world = World::new();
    world
        .add_workload(&quot;May fail&quot;)
        .with_system((
            |world: &amp;World| world.try_run(my_sys)?.map_err(Run::from_custom),
            my_sys,
        ))
        .build();
    match world.try_run_default().map_err(RunWorkload::custom_error) {
        Err(Some(error)) =&gt; {
            assert!(error.is::&lt;TerribleError&gt;());
        }
        _ =&gt; {}
    }
}</code></pre>
<p>The error has to be anonymized so you'll get back a <code>Box&lt;dyn Error + Send&gt;</code> with std and a <code>Box&lt;dyn Any + Send&gt;</code> with no_std.<br />
Workloads stop at the first error encountered, just like 0.3.<br />
You can also use the <code>try_system!</code> macro the same way as <code>system!</code>.</p>
<pre><code class="language-rust  noplaypen">world
    .add_workload(&quot;May fail&quot;)
    .with_system(try_system!(my_sys))
    .build();</code></pre>
<p>It'll generate the same code as above.</p>
<h2 id="iterator"><a class="header" href="#iterator">Iterator</a></h2>
<p>You can now use <code>std::iter::Iterator</code> and <code>for loop</code> with views without having to call <code>into_iter</code>.<br />
All iteration code from 0.3 will still work.</p>
<pre><code class="language-rust  noplaypen">fn my_sys((mut usizes, u32s): (ViewMut&lt;usize&gt;, View&lt;u32&gt;)) {
    for (i, &amp;j) in (&amp;mut usizes, &amp;u32s).iter() {
        *i += j as usize;
    }
}</code></pre>
<h2 id="get"><a class="header" href="#get">Get</a></h2>
<p>The <code>GetComponent</code> trait has been renamed <code>Get</code>.</p>
<p>What follows is only true for 0.4. 0.5 went back to <code>get</code> returning a <code>Result</code>.<br />
<code>Get::get</code> has been renamed <code>try_get</code> and a new <code>get</code> method has been added to unwrap errors.</p>
<p>If you used <code>get</code> followed by <code>unwrap</code>, you can simply remove the <code>unwrap</code>.<br />
If you used another error handling method you'll have to replace <code>get</code> by <code>try_get</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pilgrimage"><a class="header" href="#pilgrimage">Pilgrimage</a></h1>
<p>Links and information not directly related to shipyard.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-resources"><a class="header" href="#more-resources">More Resources</a></h1>
<p><a href="https://skypjack.github.io/2019-03-21-ecs-baf-part-2-insights/">Packs</a>, the whole series is a good read<br />
<a href="https://www.youtube.com/watch?v=W3aieHjyNvw">Timothy Ford's GDC talk on ECS usage in Overwatch</a><br />
<a href="https://www.youtube.com/watch?v=aKLntZcp27M">Catherine West's closing keynote on using the ECS pattern in Rust</a><br />
<a href="https://github.com/SanderMertens/ecs-faq">Sander Mertens's ECS FAQ</a><br />
<a href="https://www.richardlord.net/blog/ecs/finite-state-machines-with-ash.html">FSM in ECS</a><br />
<a href="https://github.com/abulka/todomvc-ecs">Todo MVC using ECS</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shipyard-related-crates"><a class="header" href="#shipyard-related-crates">Shipyard Related Crates</a></h1>
<p>List of crate built on top of Shipyard.<br />
Don't hesitate to contact me if your crate uses Shipyard (it doesn't have to be prefixed with &quot;shipyard&quot;).</p>
<ul>
<li><a href="https://crates.io/crates/shipyard_hierarchy">shipyard_hierarchy</a> - by <a href="https://github.com/dakom">David Komer</a> - Hierarchy crate.</li>
<li><a href="https://crates.io/crates/shipyard_scenegraph">shipyard_scenegraph</a> - by <a href="https://github.com/dakom">David Komer</a> - Scenegraph crate.</li>
<li><a href="https://github.com/storyscript/shipyard_app">shipyard_app</a> - by <a href="https://github.com/colelawrence">Cole Lawrence</a> - WIP Plugin interface being used in a commercial project.</li>
<li><a href="https://crates.io/crates/shipyard_rapier2d">shipyard_rapier2d</a> - by <a href="https://github.com/lucaspoffo">lucaspoffo</a> - An integration with the 2D physics engine rapier.</li>
<li><a href="https://crates.io/crates/shipyard_rapier3d">shipyard_rapier3d</a> - by <a href="https://github.com/lucaspoffo">lucaspoffo</a> - An integration with the 3D physics engine rapier.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="projects-using-shipyard"><a class="header" href="#projects-using-shipyard">Projects using Shipyard</a></h1>
<p>List of project using Shipyard.<br />
Don't hesitate to contact me to get your project listed.</p>
<ul>
<li><a href="https://github.com/almetica/almetica">Almetica</a> is a server for the MMORPG TERA.</li>
<li><a href="https://github.com/BoxyUwU/guacamole-runner">Guacamole Runner</a> by <a href="https://github.com/BoxyUwU">@BoxyUwU</a> is a small game where the player is constantly falling and must jump off planes to stay in the air. When they go over the top of the dirt tiles they plant flowers which gives them points.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-contributors"><a class="header" href="#guide-contributors">Guide Contributors</a></h1>
<p><a href="https://github.com/dakom">dakom - David Komer</a><br />
<a href="https://github.com/eldyer">eldyer</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
