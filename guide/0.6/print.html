<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Shipyard User&#x27;s Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="welcome.html">Welcome</a></li><li class="chapter-item expanded "><a href="fundamentals.html"><strong aria-hidden="true">1.</strong> Fundamentals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fundamentals/world.html"><strong aria-hidden="true">1.1.</strong> World</a></li><li class="chapter-item expanded "><a href="fundamentals/add-entity.html"><strong aria-hidden="true">1.2.</strong> Add Entity</a></li><li class="chapter-item expanded "><a href="fundamentals/delete-entity.html"><strong aria-hidden="true">1.3.</strong> Delete Entity</a></li><li class="chapter-item expanded "><a href="fundamentals/add-components.html"><strong aria-hidden="true">1.4.</strong> Add Components</a></li><li class="chapter-item expanded "><a href="fundamentals/remove-components.html"><strong aria-hidden="true">1.5.</strong> Remove Components</a></li><li class="chapter-item expanded "><a href="fundamentals/delete-components.html"><strong aria-hidden="true">1.6.</strong> Delete Components</a></li><li class="chapter-item expanded "><a href="fundamentals/get-and-modify.html"><strong aria-hidden="true">1.7.</strong> Get and Modify Components</a></li><li class="chapter-item expanded "><a href="fundamentals/iterators.html"><strong aria-hidden="true">1.8.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="fundamentals/uniques.html"><strong aria-hidden="true">1.9.</strong> Uniques</a></li><li class="chapter-item expanded "><a href="fundamentals/systems.html"><strong aria-hidden="true">1.10.</strong> Systems</a></li></ol></li><li class="chapter-item expanded "><a href="going-further.html"><strong aria-hidden="true">2.</strong> Going Further</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="going-further/tracking.html"><strong aria-hidden="true">2.1.</strong> Tracking</a></li><li class="chapter-item expanded "><a href="going-further/parallelism.html"><strong aria-hidden="true">2.2.</strong> Parallelism</a></li><li class="chapter-item expanded "><a href="going-further/custom-views.html"><strong aria-hidden="true">2.3.</strong> Custom Views</a></li><li class="chapter-item expanded "><a href="going-further/non-send-sync.html"><strong aria-hidden="true">2.4.</strong> !Send and !Sync Components</a></li><li class="chapter-item expanded "><a href="going-further/performance-tips.html"><strong aria-hidden="true">2.5.</strong> Performance Tips</a></li></ol></li><li class="chapter-item expanded "><a href="going-deeper.html"><strong aria-hidden="true">3.</strong> Going Deeper</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="going-deeper/workload-creation.html"><strong aria-hidden="true">3.1.</strong> Workload creation</a></li><li class="chapter-item expanded "><a href="going-deeper/sparse-set.html"><strong aria-hidden="true">3.2.</strong> Sparse Set</a></li></ol></li><li class="chapter-item expanded "><a href="recipes.html"><strong aria-hidden="true">4.</strong> Recipes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="recipes/hierarchy.html"><strong aria-hidden="true">4.1.</strong> Hierarchy</a></li><li class="chapter-item expanded "><a href="recipes/seed.html"><strong aria-hidden="true">4.2.</strong> Seed</a></li><li class="chapter-item expanded "><a href="recipes/0.4-migration.html"><strong aria-hidden="true">4.3.</strong> 0.4 migration</a></li></ol></li><li class="chapter-item expanded "><a href="pilgrimage.html"><strong aria-hidden="true">5.</strong> Pilgrimage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pilgrimage/more-resources.html"><strong aria-hidden="true">5.1.</strong> More Resources</a></li><li class="chapter-item expanded "><a href="pilgrimage/related-crates.html"><strong aria-hidden="true">5.2.</strong> Shipyard Related Crates</a></li><li class="chapter-item expanded "><a href="pilgrimage/projects-using-shipyard.html"><strong aria-hidden="true">5.3.</strong> Projects using Shipyard</a></li></ol></li><li class="chapter-item expanded "><a href="contributors.html"><strong aria-hidden="true">6.</strong> Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Shipyard User&#x27;s Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/leudz/shipyard" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-shipyard"><a class="header" href="#welcome-to-shipyard">Welcome to Shipyard!</a></h1>
<p><a href="https://github.com/leudz/shipyard">Shipyard</a> is an Entity Component System focused on usability and speed. ECS is a great way to organize logic and data.</p>
<p>There are two main benefits to using an ECS:</p>
<ol>
<li>Elegant approach for humans
<ul>
<li>Composition over inheritance</li>
<li>Separation of concerns</li>
<li>Less burdened by lifetimes</li>
</ul>
</li>
<li>Optimal design for computers
<ul>
<li>Spatial locality</li>
<li>Less pointer chasing</li>
</ul>
</li>
</ol>
<p>However, programming with an ECS requires thinking about data and logic in a different way than you might be used to.</p>
<h1 id="how-does-it-work"><a class="header" href="#how-does-it-work">How does it work?</a></h1>
<p>Components hold data. Entities are simple ids used to refer to a group of components.</p>
<p>Systems do the heavy lifting: updating components, running side-effects, and integrating with other parts of the code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamentals"><a class="header" href="#fundamentals">Fundamentals</a></h1>
<p>This section is about learning all basic ECS operations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="world"><a class="header" href="#world">World</a></h1>
<p><a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a> is Shipyard's core data structure: It holds all data and knows how to process systems. All operations originate from one (or more) <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a>.</p>
<h2 id="creation"><a class="header" href="#creation">Creation</a></h2>
<p>You can use <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.new"><code>new</code></a> or <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.default"><code>default</code></a>:</p>
<pre><code class="language-rust  noplaypen">let world = World::default();
// or
let world = World::new();</code></pre>
<h2 id="views"><a class="header" href="#views">Views</a></h2>
<p>While some actions are available directly on <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a>, you'll often interact with it through views. They allow access to one or multiple storage.<br />
Storage access follows the same rules as Rust's borrowing: as many shared accesses to a storage as you like or a single exclusive access.</p>
<p>You can request a view using <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.run"><code>World::run</code></a>, <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.borrow"><code>World::borrow</code></a> or with workloads (more on this in a later chapter).<br />
These three methods have the exact same storage access abilities.<br />
<a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.borrow"><code>borrow</code></a> has the extra ability to allow fallible storage access while workloads are about system composition.<br />
Most examples in this guide require neither so we'll use almost exclusively <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.run"><code>run</code></a>.</p>
<p>For example if you want a shared access to the entities storage:</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

world.run(|entities: EntitiesView| {});</code></pre>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>Components are identified with the <a href="https://docs.rs/shipyard/latest/shipyard/trait.Component.html"><code>Component</code></a> trait.<br />
While it can be cumbersome for small projects, this trait becomes self-documenting and helps identify what is present in the <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a>.</p>
<p>Throughout this guide we'll use a couple of components, the following snippet is assumed to be present in all other snippets:</p>
<pre><code class="language-rust  noplaypen">#[derive(Component, Debug)]
struct Pos(f32, f32);

#[derive(Component, Debug)]
struct Vel(f32, f32);</code></pre>
<p><a href="https://docs.rs/shipyard/latest/shipyard/trait.Component.html"><code>Component</code></a> can also be implemented manually.</p>
<pre><code class="language-rust  noplaypen">#[derive(Debug)]
struct Pos(f32, f32);
impl Component for Pos {
    // We'll come back to this in a later chapter
    type Tracking = track::Untracked;
}

#[derive(Debug)]
struct Vel(f32, f32);
impl Component for Vel {
    type Tracking = track::Untracked;
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-entity"><a class="header" href="#add-entity">Add Entity</a></h1>
<p>When an entity is created you will receive a unique handle to it: an <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntityId.html"><code>EntityId</code></a>.</p>
<h2 id="world-1"><a class="header" href="#world-1">World</a></h2>
<pre><code class="language-rust  noplaypen">let mut world = World::new();

let empty_entity = world.add_entity(());
let single_component = world.add_entity(Pos::new());
let multiple_components = world.add_entity((Pos::new(), Vel::new()));</code></pre>
<h2 id="views-1"><a class="header" href="#views-1">Views</a></h2>
<pre><code class="language-rust  noplaypen">let world = World::new();

world.run(
    |mut entities: EntitiesViewMut, mut vm_pos: ViewMut&lt;Pos&gt;, mut vm_vel: ViewMut&lt;Vel&gt;| {
        let empty_entity = entities.add_entity((), ());
        let single_component = entities.add_entity(&amp;mut vm_pos, Pos::new());
        let multiple_components =
            entities.add_entity((&amp;mut vm_pos, &amp;mut vm_vel), (Pos::new(), Vel::new()));
    },
);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delete-entity"><a class="header" href="#delete-entity">Delete Entity</a></h1>
<p>Deleting an entity deletes it from the entities storage, while also deleting all its components.</p>
<h2 id="world-2"><a class="header" href="#world-2">World</a></h2>
<pre><code class="language-rust  noplaypen">let mut world = World::new();

let id = world.add_entity(Pos::new());

world.delete_entity(id);</code></pre>
<h2 id="view"><a class="header" href="#view">View</a></h2>
<pre><code class="language-rust  noplaypen">let world = World::new();

world.run(|mut all_storages: AllStoragesViewMut| {
    let id = all_storages.add_entity(Pos::new());

    all_storages.delete_entity(id);
});</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-components"><a class="header" href="#add-components">Add Components</a></h1>
<p>An entity can have any number of components but only one in each storage.<br />
Adding another component of the same type will replace the existing one.</p>
<h2 id="world-3"><a class="header" href="#world-3">World</a></h2>
<pre><code class="language-rust  noplaypen">let mut world = World::new();

let id = world.add_entity(());

world.add_component(id, Vel::new());
world.add_component(id, (Pos::new(), Vel::new()));</code></pre>
<h2 id="view-1"><a class="header" href="#view-1">View</a></h2>
<p>When adding components, the entities storage is only used to check if the <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntityId.html"><code>EntityId</code></a> is alive.<br />
We don't need exclusive access to the entities storage.</p>
<p>If you don't need to check if the entity is alive, you can use the <a href="https://docs.rs/shipyard/latest/shipyard/trait.AddComponent.html"><code>AddComponent</code></a> trait and do without the entities storage entirely.</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

world.run(
    |mut entities: EntitiesViewMut, mut vm_pos: ViewMut&lt;Pos&gt;, mut vm_vel: ViewMut&lt;Vel&gt;| {
        let id = entities.add_entity((), ());

        entities.add_component(id, &amp;mut vm_pos, Pos::new());
        entities.add_component(id, (&amp;mut vm_pos, &amp;mut vm_vel), (Pos::new(), Vel::new()));
        vm_vel.add_component_unchecked(id, Vel::new());
    },
);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remove-components"><a class="header" href="#remove-components">Remove Components</a></h1>
<p>Removing a component will take it out of the storage and return it.</p>
<h2 id="world-4"><a class="header" href="#world-4">World</a></h2>
<pre><code class="language-rust  noplaypen">let mut world = World::new();

let id = world.add_entity((Pos::new(), Vel::new()));

world.remove::&lt;Vel&gt;(id);
world.remove::&lt;(Pos, Vel)&gt;(id);</code></pre>
<h2 id="view-2"><a class="header" href="#view-2">View</a></h2>
<p>We have to import the <a href="https://docs.rs/shipyard/latest/shipyard/trait.Remove.html"><code>Remove</code></a> trait for multiple components.</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

world.run(
    |mut entities: EntitiesViewMut, mut vm_pos: ViewMut&lt;Pos&gt;, mut vm_vel: ViewMut&lt;Vel&gt;| {
        let id = entities.add_entity((&amp;mut vm_pos, &amp;mut vm_vel), (Pos::new(), Vel::new()));

        vm_pos.remove(id);
        (&amp;mut vm_pos, &amp;mut vm_vel).remove(id);
    },
);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delete-components"><a class="header" href="#delete-components">Delete Components</a></h1>
<p>Deleting a component will erase it from the storage but will not return it.</p>
<h2 id="world-5"><a class="header" href="#world-5">World</a></h2>
<pre><code class="language-rust  noplaypen">let mut world = World::new();

let id = world.add_entity((Pos::new(), Vel::new()));

world.delete_component::&lt;Vel&gt;(id);
world.delete_component::&lt;(Pos, Vel)&gt;(id);</code></pre>
<h4 id="all-components"><a class="header" href="#all-components">All Components</a></h4>
<pre><code class="language-rust  noplaypen">let mut world = World::new();

let id = world.add_entity((Pos::new(), Vel::new()));

world.strip(id);</code></pre>
<h2 id="view-3"><a class="header" href="#view-3">View</a></h2>
<p>We have to import the <a href="https://docs.rs/shipyard/latest/shipyard/trait.Delete.html"><code>Delete</code></a> trait for multiple components.</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

world.run(
    |mut entities: EntitiesViewMut, mut vm_pos: ViewMut&lt;Pos&gt;, mut vm_vel: ViewMut&lt;Vel&gt;| {
        let id = entities.add_entity((&amp;mut vm_pos, &amp;mut vm_vel), (Pos::new(), Vel::new()));

        vm_pos.delete(id);
        (&amp;mut vm_pos, &amp;mut vm_vel).delete(id);
    },
);</code></pre>
<h4 id="all-components-1"><a class="header" href="#all-components-1">All Components</a></h4>
<pre><code class="language-rust  noplaypen">let world = World::new();

world.run(|mut all_storages: AllStoragesViewMut| {
    let id = all_storages.add_entity((Pos::new(), Vel::new()));

    all_storages.strip(id);
});</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-and-modify-components"><a class="header" href="#get-and-modify-components">Get and Modify Components</a></h1>
<p>To access or update components you can use <a href="https://docs.rs/shipyard/latest/shipyard/trait.Get.html#tymethod.get"><code>Get::get</code></a>. It'll work with both shared and exclusive views.</p>
<pre><code class="language-rust  noplaypen">let mut world = World::new();

let id = world.add_entity((Pos::new(), Vel::new()));

world.run(|mut vm_pos: ViewMut&lt;Pos&gt;, mut vm_vel: ViewMut&lt;Vel&gt;| {
    (&amp;mut vm_vel).get(id).unwrap().0 += 1.0;

    let (mut i, j) = (&amp;mut vm_pos, &amp;vm_vel).get(id).unwrap();
    i.0 += j.0;

    vm_pos[id].0 += 1.0;
});</code></pre>
<p>When using a single view, if you are certain an entity has the desired component, you can access it via index.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<p>Iteration is one of the most important features of an ECS.</p>
<p>In Shipyard this is achieved using <a href="https://docs.rs/shipyard/latest/shipyard/trait.IntoIter.html#tymethod.iter"><code>IntoIter::iter</code></a> on views.</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

world.run(|mut vm_pos: ViewMut&lt;Pos&gt;, v_vel: View&lt;Vel&gt;| {
    for i in vm_pos.iter() {
        dbg!(i);
    }
    
    for (i, j) in (&amp;mut vm_pos, &amp;v_vel).iter() {
        i.0 += j.0;
    }
});</code></pre>
<p>You can use views in any order. However, using the same combination of views in different positions might yield components in a different order.<br />
You shouldn't expect specific ordering from Shipyard's iterators in general.</p>
<h4 id="with-id"><a class="header" href="#with-id">With Id</a></h4>
<p>You can ask an iterator to tell you which entity owns each component by using <a href="https://docs.rs/shipyard/latest/shipyard/trait.IntoWithId.html#method.with_id"><code>WithId::with_id</code></a>:</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

world.run(|v_pos: View&lt;Pos&gt;| {
    for (id, i) in v_pos.iter().with_id() {
        println!(&quot;{:?} belongs to entity {:?}&quot;, i, id);
    }
});</code></pre>
<h4 id="not"><a class="header" href="#not">Not</a></h4>
<p>It's possible to filter entities that don't have a certain component using <a href="https://docs.rs/shipyard/latest/shipyard/struct.Not.html"><code>Not</code></a> by adding <code>!</code> in front of the view reference.</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

world.run(|v_pos: View&lt;Pos&gt;, v_vel: View&lt;Vel&gt;| {
    for (i, _) in (&amp;v_pos, !&amp;v_vel).iter() {
        dbg!(i);
    }
});</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unique"><a class="header" href="#unique">Unique</a></h1>
<p>Unique components (a.k.a. resources) are useful when you know there will only ever be a single instance of some component.<br />
In that case there is no need to attach the component to an entity. It also works well as global data without most of its drawback.</p>
<p>As opposed to the default storage uniques are declared using the <a href="https://docs.rs/shipyard/latest/shipyard/trait.Unique.html"><code>Unique</code></a> trait.</p>
<pre><code class="language-rust  noplaypen">// Using a derive macro
#[derive(Unique)]
struct Camera;

// By manually implementing the trait
struct Camera;
impl Unique for Camera {}</code></pre>
<p>They also need to be initialized with <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.add_unique"><code>add_unique</code></a>. We can then access them with <a href="https://docs.rs/shipyard/latest/shipyard/struct.UniqueView.html"><code>UniqueView</code></a> and <a href="https://docs.rs/shipyard/latest/shipyard/struct.UniqueViewMut.html"><code>UniqueViewMut</code></a>.</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

world.add_unique(Camera::new());

world
    .run(|camera: UniqueView&lt;Camera&gt;| {
        // -- snip --
    });</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systems"><a class="header" href="#systems">Systems</a></h1>
<p>Systems are a great way to organize code.<br />
A function with views as arguments is all you need.</p>
<p>Here's an example:</p>
<pre><code class="language-rust  noplaypen">fn create_ints(mut entities: EntitiesViewMut, mut vm_vel: ViewMut&lt;Vel&gt;) {
    // -- snip --
}</code></pre>
<p>We have a system, let's run it!</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

world.run(create_ints);</code></pre>
<p>It also works with closures, all previous chapters were using systems.</p>
<h3 id="workloads"><a class="header" href="#workloads">Workloads</a></h3>
<p>A workload is a group of systems.</p>
<pre><code class="language-rust  noplaypen">fn create_ints(mut entities: EntitiesViewMut, mut vm_vel: ViewMut&lt;Vel&gt;) {
    // -- snip --
}

fn delete_ints(mut vm_vel: ViewMut&lt;Vel&gt;) {
    // -- snip --
}

fn int_cycle() -&gt; Workload {
    (create_ints, delete_ints).into_workload()
}

let world = World::new();

world.add_workload(int_cycle);

world.run_workload(int_cycle).unwrap();</code></pre>
<p>They are stored in the <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a>, ready to be run again and again.</p>
<p>Workloads will run their systems first to last and try to run them in parallel when possible. We call this <em>outer-parallelism</em>, you can learn more about it in <a href="fundamentals/../going-further/parallelism.html">this chapter</a>.</p>
<h4 id="workload-nesting"><a class="header" href="#workload-nesting">Workload Nesting</a></h4>
<p>You can also add a workload to another and build your execution logic brick by brick.</p>
<pre><code class="language-rust  noplaypen">#[derive(Component)]
struct Dead&lt;T: 'static + Send + Sync&gt;(core::marker::PhantomData&lt;T&gt;);

fn increment(mut vm_vel: ViewMut&lt;Vel&gt;) {
    for i in (&amp;mut vm_vel).iter() {
        i.0 += 1.0;
    }
}

fn flag_deleted_vel(v_vel: View&lt;Vel&gt;, mut deads: ViewMut&lt;Dead&lt;Vel&gt;&gt;) {
    for (id, i) in v_vel.iter().with_id() {
        if i.0 &gt; 100.0 {
            deads.add_component_unchecked(id, Dead(core::marker::PhantomData));
        }
    }
}

fn clear_deleted_vel(mut all_storages: AllStoragesViewMut) {
    all_storages.delete_any::&lt;SparseSet&lt;Dead&lt;Vel&gt;&gt;&gt;();
}

fn filter_vel() -&gt; Workload {
    (flag_deleted_vel, clear_deleted_vel).into_workload()
}

fn main_loop() -&gt; Workload {
    (increment, filter_vel).into_workload()
}

let world = World::new();

world.add_workload(main_loop);

world.run_workload(main_loop).unwrap();</code></pre>
<hr />
<p>Congratulations, you made it to the end of the fundamentals!<br />
The next section will explore less universal topics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="going-further"><a class="header" href="#going-further">Going Further</a></h1>
<p>This section covers patterns that are not needed for all projects but come in handy when the situation requires it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracking"><a class="header" href="#tracking">Tracking</a></h1>
<p>Shipyard comes with built-in tracking for <em>insertion</em>, <em>modification</em>, <em>deletion</em> and <em>removal</em>.<br />
<em>deletion</em> will store the component in the tracking info whereas <em>removal</em> gives it back immediately.<br />
It can be noticed on <code>SparseSet::delete</code> vs <code>SparseSet::remove</code> signatures:</p>
<pre><code class="language-rs">fn delete(&amp;mut self, entity: EntityId) -&gt; bool {}
fn remove(&amp;mut self, entity: EntityId) -&gt; Option&lt;T&gt; {}
</code></pre>
<p>Components can be deleted or removed but whole entities can only be deleted (at least for now, it's technically possible to return something but I digress).</p>
<h2 id="declaration"><a class="header" href="#declaration">Declaration</a></h2>
<p>Tracking is set with the <code>Component</code> trait. You can set it to any single operation or use <code>All</code> to track everything.</p>
<pre><code class="language-rs">struct Life(f32);
impl Component for Life {
    type Tracking = track::Modification;
}

// or with the proc macro

#[derive(Component)]
#[track(Modification)]
struct Life(f32);
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>When inside a workload you will get all tracking information since the last time this system ran.<br />
Outside workloads you'll get information since the last call to <code>clear_*</code>.</p>
<h4 id="inserted-or-modified"><a class="header" href="#inserted-or-modified"><em>Inserted</em> or <em>Modified</em></a></h4>
<p>You can query <em>inserted</em> and <em>modified</em> components when iterating by calling <code>inserted</code>, <code>modified</code> or <code>inserted_or_modified</code> on a view before making the iterator. (*_mut versions also exist).</p>
<pre><code class="language-rs">fn run(life: View&lt;Life&gt;, mut is_dead: ViewMut&lt;IsDead&gt;) {
    for (entity, life) in life.modified().iter().with_id() {
        if life.0 &lt;= 0.0 {
            is_dead.add_component_unchecked(entity, IsDead);
        }
    }
}
</code></pre>
<h4 id="removed-or-deleted"><a class="header" href="#removed-or-deleted"><em>Removed</em> or <em>Deleted</em></a></h4>
<p><em>Removed</em> and <em>deleted</em> cannot be used with <code>iter</code> but can be accessed with <code>removed</code>, <code>deleted</code> or <code>removed_or_deleted</code> methods on views.</p>
<h2 id="reset"><a class="header" href="#reset">Reset</a></h2>
<p>Inside workloads tracking information doesn't need to be reset. You will always get the operations that happened since the last run of the system.</p>
<p>You can reset out of workload tracking info with:</p>
<ul>
<li><code>clear_all_inserted</code></li>
<li><code>clear_all_modified</code></li>
<li><code>clear_all_inserted_and_modified</code></li>
<li><code>clear_all_removed</code></li>
<li><code>clear_all_deleted</code></li>
<li><code>clear_all_removed_and_deleted</code></li>
</ul>
<p>You can also reset removed and deleted information older than some timestamp.</p>
<p>Use <code>World::get_tracking_timestamp</code> or <code>AllStorages::get_tracking_timestamp</code> to get a timestamp.<br />
Then call <code>clear_all_deleted_older_than_timestamp</code>, <code>clear_all_removed_older_than_timestamp</code> or <code>clear_all_removed_or_deleted_older_than_timestamp</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parallelism"><a class="header" href="#parallelism">Parallelism</a></h1>
<p>By late 90s - early 2000s, CPUs started to get too close to the physical limitation of transistors and manufacturers couldn't &quot;just&quot; make their product faster. The solution: more cores.</p>
<p>Nowadays almost all devices come with multiple cores, it would be a shame to use just one.</p>
<p>In ECS there's two big ways to split work across cores: running systems on separate threads or using a parallel iterator, we call these two methods &quot;outer-parallelism&quot; and &quot;inner-parallelism,&quot; respectively.</p>
<h3 id="outer-parallelism"><a class="header" href="#outer-parallelism">Outer-parallelism</a></h3>
<p>We'll start by the simplest one to use. So simple that there's nothing to do, workloads handle all the work for you. We even almost used multiple threads in the <a href="going-further/../fundamentals/systems.html">Systems chapter</a>.</p>
<p>As long as the &quot;parallel&quot; feature is set (enabled by default) workloads will try to execute systems as much in parallel as possible. There is a set of rules that defines the &quot;possible&quot;:</p>
<ul>
<li>Systems accessing <a href="https://docs.rs/shipyard/latest/shipyard/struct.AllStorages.html"><code>AllStorages</code></a> stop all threading.</li>
<li>There can't be any other access during an exclusive access, so <a href="https://docs.rs/shipyard/latest/shipyard/struct.ViewMut.html"><code>ViewMut&lt;T&gt;</code></a> will block <code>T</code> threading.</li>
</ul>
<p>When you make a workload, all systems in it will be checked and batches (groups of systems that don't conflict) will be created.<br />
<a href="https://docs.rs/shipyard/latest/shipyard/struct.Workload.html#method.add_to_world"><code>add_to_world</code></a> returns information about these batches and why each system didn't get into the previous batch.</p>
<h3 id="inner-parallelism"><a class="header" href="#inner-parallelism">Inner-parallelism</a></h3>
<p>While parallel iterators does require us to modify our code, it's just a matter of using <code>par_iter</code> instead of <code>iter</code>.<br />
Don't forget to import rayon. <a href="https://docs.rs/shipyard/latest/shipyard/trait.IntoIter.html#tymethod.par_iter"><code>par_iter</code></a> returns a <a href="https://docs.rs/rayon/latest/rayon/iter/trait.ParallelIterator.html"><code>ParallelIterator</code></a>.</p>
<p>Example:</p>
<pre><code class="language-rust  noplaypen">use rayon::prelude::*;

fn many_vm_pos(mut vm_pos: ViewMut&lt;Pos&gt;) {
    vm_pos.par_iter().for_each(|i| {
        // -- snip --
    });
}</code></pre>
<p>Don't replace all your <a href="https://docs.rs/shipyard/latest/shipyard/trait.IntoIter.html#tymethod.iter"><code>iter</code></a> method calls just yet, however! Using a parallel iterator comes with an upfront overhead cost. It will only exceed the speed of its sequential counterpart on computations expensive enough to make up for the overhead cost in improved processing efficiency.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-views"><a class="header" href="#custom-views">Custom Views</a></h1>
<p>Custom views are types that you can borrow (like <code>View</code> or <code>UniqueView</code>) but are not provided by <code>shipyard</code>.</p>
<p>Many types can become custom views, they'll fall into one of two categories: View Bundle or Wild View.
View bundles only contain other views while wild views can contain other types.</p>
<p>Example of a View Bundle:</p>
<pre><code class="language-rust  noplaypen">struct Hierarchy&lt;'v&gt; {
    entities: EntitiesViewMut&lt;'v&gt;,
    parents: ViewMut&lt;'v, Parent&gt;,
    children: ViewMut&lt;'v, Child&gt;,
}</code></pre>
<p>Example of a Wild View:</p>
<pre><code class="language-rust  noplaypen">struct RandomNumber(u64);</code></pre>
<h3 id="concrete-example"><a class="header" href="#concrete-example">Concrete example</a></h3>
<p>When creating a frame with any low level api there is always some boilerplate. We'll look at how custom views can help for <code>wgpu</code>.</p>
<p>The original code creates the frame in a system by borrowing <code>Graphics</code> which contains everything needed.
The rendering part just clears the screen with a color.</p>
<p>The entire starting code for this chapter is available in <a href="going-further/./custom_views_original.rs">this file</a>. You can copy all of it in a fresh <code>main.rs</code> and edit the fresh <code>Cargo.toml</code>.</p>
<details>
<summary>Original</summary>
<pre><code class="language-rust  noplaypen">#[derive(Unique)]
struct Graphics {
    surface: wgpu::Surface,
    device: wgpu::Device,
    queue: wgpu::Queue,
    config: wgpu::SurfaceConfiguration,
    size: winit::dpi::PhysicalSize&lt;u32&gt;,
}

fn render(graphics: UniqueView&lt;Graphics&gt;) -&gt; Result&lt;(), wgpu::SurfaceError&gt; {
    // Get a few things from the GPU
    let output = graphics.surface.get_current_texture()?;
    let view = output
        .texture
        .create_view(&amp;wgpu::TextureViewDescriptor::default());

    let mut encoder = graphics
        .device
        .create_command_encoder(&amp;wgpu::CommandEncoderDescriptor {
            label: Some(&quot;Render Encoder&quot;),
        });

    {
        // RenderPass borrows encoder for all its lifetime
        let mut _render_pass = encoder.begin_render_pass(&amp;wgpu::RenderPassDescriptor {
            label: Some(&quot;Render Pass&quot;),
            color_attachments: &amp;[wgpu::RenderPassColorAttachment {
                view: &amp;view,
                resolve_target: None,
                ops: wgpu::Operations {
                    load: wgpu::LoadOp::Clear(wgpu::Color {
                        r: 0.1,
                        g: 0.2,
                        b: 0.3,
                        a: 1.0,
                    }),
                    store: true,
                },
            }],
            depth_stencil_attachment: None,
        });
    }

    // encoder.finish() consumes `encoder`, so the RenderPass needs to disappear before that to release the borrow
    graphics.queue.submit(iter::once(encoder.finish()));
    output.present();

    Ok(())
}</code></pre>
</details>
<p>We want to abstract the beginning and end of the system to get this version working.
The error handling is going to move, we could keep it closer to the original by having a <code>ResultRenderGraphicsViewMut</code> for example. </p>
<pre><code class="language-rust  noplaypen">fn render(mut graphics: RenderGraphicsViewMut) {
    let mut _render_pass = graphics
        .encoder
        .begin_render_pass(&amp;wgpu::RenderPassDescriptor {
            label: Some(&quot;Render Pass&quot;),
            color_attachments: &amp;[wgpu::RenderPassColorAttachment {
                view: &amp;graphics.view,
                resolve_target: None,
                ops: wgpu::Operations {
                    load: wgpu::LoadOp::Clear(wgpu::Color {
                        r: 0.1,
                        g: 0.2,
                        b: 0.3,
                        a: 1.0,
                    }),
                    store: true,
                },
            }],
            depth_stencil_attachment: None,
        });
}</code></pre>
<p>We'll start by creating a struct to hold our init state.</p>
<pre><code class="language-rust  noplaypen">struct RenderGraphicsViewMut {
    view: wgpu::TextureView,
    encoder: wgpu::CommandEncoder,
}</code></pre>
<p>Now let's make this struct able to be borrowed and generate the initial state we need.</p>
<pre><code class="language-rust  noplaypen">impl&lt;'v&gt; shipyard::Borrow&lt;'v&gt; for RenderGraphicsViewMut {
    type View = RenderGraphicsViewMut;

    fn borrow(
        world: &amp;'v shipyard::World,
        last_run: Option&lt;u32&gt;,
        current: TrackingTimestamp,
    ) -&gt; Result&lt;Self::View, shipyard::error::GetStorage&gt; {
        // Even if we don't use tracking for Graphics, it's good to build an habit of using last_run and current when creating custom views
        let graphics = &lt;UniqueView&lt;Graphics&gt; as shipyard::IntoBorrow&gt;::Borrow::borrow(
            world, last_run, current,
        )?;
        // This error will now be reported as an error during the view creation process and not the system but is still bubbled up
        let output = graphics
            .surface
            .get_current_texture()
            .map_err(shipyard::error::GetStorage::from_custom)?;
        let view = output
            .texture
            .create_view(&amp;wgpu::TextureViewDescriptor::default());

        let encoder = graphics
            .device
            .create_command_encoder(&amp;wgpu::CommandEncoderDescriptor {
                label: Some(&quot;Render Encoder&quot;),
            });

        Ok(RenderGraphicsViewMut {
            encoder,
            view,
        })
    }
}</code></pre>
<p>We now have a custom view! We can't change our system just yet, we're missing <code>output</code>.</p>
<p>Let's add <code>output</code> and <code>graphics</code> to our custom view.</p>
<pre><code class="language-rust  noplaypen">struct RenderGraphicsViewMut&lt;'v&gt; {
    encoder: wgpu::CommandEncoder,
    view: wgpu::TextureView,
    // New fields
    output: Option&lt;wgpu::SurfaceTexture&gt;,
    graphics: UniqueView&lt;'v, Graphics&gt;,
}</code></pre>
<p>Since our view now has a lifetime we need a bit of boilerplate (<a href="going-further/../going-deeper/workload-creation.html">explanation</a>).</p>
<pre><code class="language-rust  noplaypen">struct RenderGraphicsBorrower {}

impl shipyard::IntoBorrow for RenderGraphicsViewMut&lt;'_&gt; {
    type Borrow = RenderGraphicsBorrower;
}</code></pre>
<p>With that our of the way we can revisit our <code>Borrow</code> implementation and add one for <code>Drop</code>.</p>
<pre><code class="language-rust  noplaypen">impl&lt;'v&gt; shipyard::Borrow&lt;'v&gt; for RenderGraphicsBorrower {
    type View = RenderGraphicsViewMut&lt;'v&gt;;

    fn borrow(
        world: &amp;'v shipyard::World,
        last_run: Option&lt;u32&gt;,
        current: TrackingTimestamp,
    ) -&gt; Result&lt;Self::View, shipyard::error::GetStorage&gt; {
        let graphics = &lt;UniqueView&lt;Graphics&gt; as shipyard::IntoBorrow&gt;::Borrow::borrow(
            world, last_run, current,
        )?;
        let output = graphics
            .surface
            .get_current_texture()
            .map_err(shipyard::error::GetStorage::from_custom)?;
        let view = output
            .texture
            .create_view(&amp;wgpu::TextureViewDescriptor::default());

        let encoder = graphics
            .device
            .create_command_encoder(&amp;wgpu::CommandEncoderDescriptor {
                label: Some(&quot;Render Encoder&quot;),
            });

        Ok(RenderGraphicsViewMut {
            encoder,
            view,
            output: Some(output),
            graphics,
        })
    }
}

impl Drop for RenderGraphicsViewMut&lt;'_&gt; {
    fn drop(&amp;mut self) {
        // I chose to swap here to not have to use an `Option&lt;wgpu::CommandEncoder&gt;` in a publicly accessible field
        let encoder = std::mem::replace(
            &amp;mut self.encoder,
            self.graphics
                .device
                .create_command_encoder(&amp;wgpu::CommandEncoderDescriptor {
                    label: Some(&quot;Render Encoder&quot;),
                }),
        );

        self.graphics.queue.submit(iter::once(encoder.finish()));
        // output on the other hand is only used here so an `Option` is good enough
        self.output.take().unwrap().present();
    }
}</code></pre>
<p>Our custom view is now fully functional and we successfully moved code that would be duplicated out of the render system.
You can remove the error handling in <code>main.rs</code> to see the result.</p>
<p>As a final touch we can implement <code>BorrowInfo</code> and <code>AllStoragesBorrow</code>. Respectively to make our view work with workloads and <code>AllStorages</code>.</p>
<pre><code class="language-rust  noplaypen">// SAFE: All storages info is recorded.
unsafe impl shipyard::BorrowInfo for RenderGraphicsViewMut&lt;'_&gt; {
    fn borrow_info(info: &amp;mut Vec&lt;shipyard::info::TypeInfo&gt;) {
        &lt;UniqueView&lt;Graphics&gt;&gt;::borrow_info(info);
    }
}

impl&lt;'v&gt; shipyard::AllStoragesBorrow&lt;'v&gt; for RenderGraphicsBorrower {
    fn all_borrow(
        all_storages: &amp;'v shipyard::AllStorages,
        last_run: Option&lt;u32&gt;,
        current: TrackingTimestamp,
    ) -&gt; Result&lt;Self::View, shipyard::error::GetStorage&gt; {
        let graphics = &lt;UniqueView&lt;Graphics&gt; as shipyard::IntoBorrow&gt;::Borrow::all_borrow(
            all_storages,
            last_run,
            current,
        )?;
        let output = graphics
            .surface
            .get_current_texture()
            .map_err(shipyard::error::GetStorage::from_custom)?;
        let view = output
            .texture
            .create_view(&amp;wgpu::TextureViewDescriptor::default());

        let encoder = graphics
            .device
            .create_command_encoder(&amp;wgpu::CommandEncoderDescriptor {
                label: Some(&quot;Render Encoder&quot;),
            });

        Ok(RenderGraphicsViewMut {
            encoder,
            view,
            output: Some(output),
            graphics,
        })
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-and-sync-components"><a class="header" href="#send-and-sync-components"><code>!Send</code> and <code>!Sync</code> Components</a></h1>
<p><a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a> can store <code>!Send</code> and/or <code>!Sync</code> components once the <code>thread_local</code> feature is set but they come with limitations:</p>
<ul>
<li><code>!Send</code> storages can only be added in <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a>'s thread.</li>
<li><code>Send + !Sync</code> components can only be accessed from one thread at a time.</li>
<li><code>!Send + Sync</code> components can only be accessed immutably from other threads.</li>
<li><code>!Send + !Sync</code> components can only be accessed in the thread they were added in.</li>
</ul>
<p>These storages are accessed with <a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSend.html"><code>NonSend</code></a>, <a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSync.html"><code>NonSync</code></a> and <a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSendSync.html"><code>NonSendSync</code></a>, for example:</p>
<pre><code class="language-rust  noplaypen">#[derive(Unique)]
struct RcU32(Rc&lt;u32&gt;);
#[derive(Component)]
struct RcUSIZE(Rc&lt;usize&gt;);

#[allow(unused)]
fn run(rcs_usize: NonSendSync&lt;View&lt;RcUSIZE&gt;&gt;, rc_u32: NonSendSync&lt;UniqueView&lt;RcU32&gt;&gt;) {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h1>
<p>List of small information to get the most out of Shipyard.</p>
<h3 id="for_each"><a class="header" href="#for_each"><code>for_each</code></a></h3>
<p><code>for ... in</code> desugars to calling <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next"><code>next</code></a> repeatedly, the compiler can sometimes optimize it very well.<br />
If you don't want to take any chance prefer calling <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.for_each"><code>for_each</code></a> instead.</p>
<h3 id="borrow--run-in-a-loop"><a class="header" href="#borrow--run-in-a-loop"><code>borrow</code> / <code>run</code> in a loop</a></h3>
<p>While borrowing storages is quite cheap, doing so in a loop is generally a bad idea.<br />
Prefer moving the loop inside <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.run"><code>run</code></a> and move <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.borrow"><code>borrow</code></a>'s call outside the loop.</p>
<h3 id="bulk_add_entity"><a class="header" href="#bulk_add_entity"><code>bulk_add_entity</code></a></h3>
<p>When creating many entities at the same time remember to call <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.bulk_add_entity"><code>bulk_add_entity</code></a> if possible.</p>
<h3 id="deleting-entities"><a class="header" href="#deleting-entities">Deleting entities</a></h3>
<p>This is a niche optimization but the methods presented in the <a href="going-further/../fundamentals/delete-components.html">Delete Components</a> chapter are not always the fastest way to delete an entity.</p>
<p>When an entity is deleted, all storages have to be checked to delete the components of that entity.
But if you know which components this entity might have, you can focus the search on those and ignore the other storages.</p>
<p>Instead of calling <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.delete_entity">World::delete_entity</a> or <a href="https://docs.rs/shipyard/latest/shipyard/struct.AllStorages.html#method.delete_entity">AllStorages::delete_entity</a> you can call <code>delete</code> on all potential storages using the <a href="https://docs.rs/shipyard/latest/shipyard/trait.Delete.html">Delete</a> trait and <a href="https://docs.rs/shipyard/latest/shipyard/struct.Entities.html#method.delete_unchecked">Entities::delete_unchecked</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="going-further-1"><a class="header" href="#going-further-1">Going Further</a></h1>
<p>This section covers the inner working of shipyard. As a user you don't need to know any of this to leverage everything shipyard can offer.</p>
<p>If you want to contribute or make your own ECS this section can be handy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workload-creation"><a class="header" href="#workload-creation">Workload creation</a></h1>
<p>There are a few trickeries going on with workload's creation.<br />
In this chapter we'll look under the hood to understand how shipyard accept:</p>
<pre><code class="language-rs">Workload::builder(&quot;Add &amp; Check&quot;)
    .with_system(add);
</code></pre>
<h2 id="intoborrow"><a class="header" href="#intoborrow">IntoBorrow</a></h2>
<p>Let's start with <code>Workload::with_system</code>.<br />
It should accept any system, a system being a function with 0 to 10 views as arguments and returning anything.<br />
Since it has to accept multiple types we have to make a trait, <code>IntoWorkloadSystem</code>.<br />
Ideally this trait would be implemented like this:</p>
<pre><code class="language-rs">trait Borrow {
    type View&lt;'v&gt;;
    fn borrow&lt;'a&gt;(world: &amp;'a World) -&gt; Result&lt;Self::View&lt;'a&gt;, error::GetStorage&gt;;
}

impl&lt;$($view: Borrow + BorrowInfo,)+ R, Sys&gt; IntoWorkloadSystem&lt;($($view,)+), R&gt; for Sys
where
    Sys:
        Fn($($view),+) -&gt; R
        + 'static
        + Send
        + Sync {
</code></pre>
<p>But GAT are not stable so we can't have <code>View&lt;'v&gt;</code> as an associated type.
Today we have to write:</p>
<pre><code class="language-rs">trait Borrow&lt;'v&gt; {
    type View;
    fn borrow(world: &amp;'v World) -&gt; Result&lt;Self::View, error::GetStorage&gt;;
}
</code></pre>
<p>Then <code>IntoWorkloadSystem</code> becomes:</p>
<pre><code class="language-rs">impl&lt;$($view: for&lt;'v&gt; Borrow&lt;'v&gt; + BorrowInfo,)+ R, Sys&gt; IntoWorkloadSystem&lt;($($view,)+), R&gt; for Sys
where
    Sys:
        Fn($($view),+) -&gt; R
        + 'static
        + Send
        + Sync {
</code></pre>
<p>But the compiler isn't happy.<br />
At the end of the day, views don't implement <code>Borrow</code> for all lifetimes. Views only implement <code>Borrow</code> for their lifetime.<br />
For example <code>View&lt;'a, T&gt;</code> will only implement <code>Borrow&lt;'a&gt;</code>, if you try <code>Borrow&lt;'b&gt;</code> it shouldn't work.</p>
<p>And you can see it with <code>()</code>, the unit type actually implements <code>Borrow</code> for all lifetimes and the compiler will accept functions that take a unit as argument.</p>
<p>So instead we don't make a single <code>Borrow</code> trait, but 2:</p>
<ul>
<li><code>IntoBorrow</code> has the ability to give us a type that implements <code>Borrow</code> for all lifetimes</li>
<li><code>Borrow</code> will use this type and give us the actual view
Then we can tie both lifetimes to make it valid.</li>
</ul>
<pre><code class="language-rs">impl&lt;$($view: IntoBorrow + BorrowInfo,)+ R, Sys&gt; IntoWorkloadSystem&lt;($($view,)+), R&gt; for Sys
where
    for&lt;'s&gt; Sys:
        Fn($($view),+) -&gt; R
        + Fn($(&lt;$view::Borrow as Borrow&lt;'s&gt;&gt;::View),+) -&gt; R
        + 'static
        + Send
        + Sync {
</code></pre>
<p><code>IntoBorrow</code> instead of <code>for&lt;'a&gt; Borrow&lt;'a&gt;</code> and the two bounds on <code>Sys</code> will tie the lifetime of the views from the function's arguments (<code>'s</code>) to the views returned by <code>Borrow</code>.</p>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<p>If you implement <code>IntoWorkloadSystem</code> like shown above you'll notice that it works but only for references to functions.
I don't know why, so the real implementation is:</p>
<pre><code class="language-rs">impl&lt;$($view: IntoBorrow + BorrowInfo,)+ R, Sys&gt; IntoWorkloadSystem&lt;($($view,)+), R&gt; for Sys
where
    Sys: 'static
        + Send
        + Sync,
    for&lt;'a, 'b&gt; &amp;'b Sys:
        Fn($($view),+) -&gt; R
        + Fn($(&lt;$view::Borrow as Borrow&lt;'a&gt;&gt;::View),+) -&gt; R {
</code></pre>
<p>We take the system as value and make sure it's <code>'static + Send + Sync</code> then in <code>IntoWorkloadSystem</code> implementation we'll take a reference to it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sparse-set"><a class="header" href="#sparse-set">Sparse Set</a></h1>
<p><a href="https://docs.rs/shipyard/latest/shipyard/struct.SparseSet.html"><code>SparseSet</code></a> is Shipyard's default storage. This chapter explains the basics
of how it works, the actual implementation is more optimized both in term of speed and memory.</p>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<p>To understand how Shipyard uses sparse sets, we must first understand how sparse sets work.
A basic sparse set is a data structure for storing integers. It is comprised of two
arrays: <code>sparse</code> and <code>dense</code>.</p>
<p>To insert an integer <code>i</code>, we first set the next available slot in the <code>dense</code> array to <code>i</code>,
and then set <code>sparse[i]</code> to the position of <code>i</code> in the dense array. Let's walk through
an example.</p>
<p>We start off with an empty sparse set:</p>
<ul>
<li>Sparse Array: <code>[]</code></li>
<li>Dense Array: <code>[]</code></li>
</ul>
<p>To add <code>3</code> to our sparse set, we first append it to <code>dense</code> and then set <code>sparse[3]</code> to <code>0</code>
(the position of <code>3</code> in <code>dense</code>):</p>
<ul>
<li>Sparse Array: <code>[U, U, 0]</code></li>
<li>Dense Array: <code>[3]</code>
<code>U</code> is short for uninitialised.</li>
</ul>
<p>If we then add <code>0</code>, the sparse set will look like so:</p>
<ul>
<li>Sparse Array: <code>[1, U, 0]</code></li>
<li>Dense Array: <code>[3, 0]</code></li>
</ul>
<p>Searching a sparse set is <code>O(1)</code>. To check if the integer <code>i</code> exists we check whether
<code>dense[sparse[i]] == i</code>. For example, to look up <code>3</code> in our example sparse set, we should
first check <code>sparse[check]</code>. <code>sparse[check]</code> is equal to <code>0</code> and so next we check
<code>dense[0]</code>. Since <code>dense[0] == 3</code> we can say that <code>3</code> is in our example sparse set.</p>
<h3 id="shipyard"><a class="header" href="#shipyard">Shipyard</a></h3>
<p>So far, we've only seen how sparse sets can store integers. However, Shipyard has to store both
entity IDs (basically just integers) and components, requiring us to use a slightly more
complicated data structure. Shipyard makes two major changes to the traditional sparse set
described above.</p>
<p>Firstly, Shipyard sparse sets are actually composed of three arrays: <code>sparse</code>, <code>dense</code>, and
<code>data</code>. <code>dense</code> stores the entity IDs, whereas <code>data</code> contains the actual components of the
entities. <code>dense</code> and <code>data</code> are linked: their lengths are always the same. <code>data[i]</code> is
the component for the entity with the ID located at <code>dense[i]</code>. Whenever <code>dense</code> changes,
so does <code>data</code>.</p>
<p>Secondly, Shipyard uses multiple sparse sets, one for each type of component. The <code>dense</code> array
in each sparse set contains the <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntityId.html"><code>EntityIds</code></a> of the entities that have that
component.</p>
<p>Let's walk through an example:</p>
<pre><code class="language-rust noplaypen">#[derive(Component)]
struct FirstComponent(pub u32);

#[derive(Component)]
struct SecondComponent(pub u32);

let mut world = World::new();

let entity_id_0 = world.add_entity((FirstComponent(322),));
let entity_id_1 = world.add_entity((SecondComponent(17),));
let entity_id_2 = world.add_entity((FirstComponent(5050), SecondComponent(3154)));
let entity_id_3 = world.add_entity((FirstComponent(958),));</code></pre>
<p>For this example we will assume that the entity IDs are in order i.e. <code>entity_id_0 == 0</code>, <code>entity_id_1 == 1</code>, etc.</p>
<p>The world data will now be stored in two sparse sets, one for each component:</p>
<pre><code class="language-txt">SparseSet&lt;FirstComponent&gt;:
    sparse: [0, U, 1, 2]
    dense:  [0, 2, 3]
    data:   [FirstComponent(322), FirstComponent(5050), FirstComponent(958)]

SparseSet&lt;SecondComponent&gt;:
    sparse: [U, 0, 1]
    dense:  [1, 2]
    data:   [SecondComponent(17), SecondComponent(3154)]
</code></pre>
<p><code>U</code> is short for uninitialised.</p>
<h3 id="iteration"><a class="header" href="#iteration">Iteration</a></h3>
<p>To iterate over a single sparse set, we can simply iterate over the <code>data</code> array.
However, Shipyard also lets us iterate over multiple sparse sets.</p>
<p>To iterate over multiple sparse sets, we first pick the shortest set (comparing the lengths
of the <code>dense</code> arrays) and then iterate over the <code>dense</code> array of the shortest set. For each
entity ID, we check whether all the other sparse sets contain it, and if they do, we yield
the entity ID in the iterator.</p>
<p>Let's walk through an example with the sparse set we defined above:</p>
<pre><code class="language-rust noplaypen">let (firsts, seconds) = world
	.borrow::&lt;(View&lt;FirstComponent&gt;, View&lt;SecondComponent&gt;)&gt;()
	.unwrap();

for (first, second) in (&amp;firsts, &amp;seconds).iter() {
	// Do some stuff
}</code></pre>
<p>We first check which has the shortest dense set. The <code>SecondComponent</code> sparse set does, so
we begin iterating over its <code>dense</code> array.</p>
<p>The first entity ID is <code>1</code>. Since we are iterating over <code>SecondComponent</code>, we already know
that entity <code>1</code> has a <code>SecondComponent</code>; we just need to check if the entity has a
<code>FirstComponent</code>. As described above, to check whether an entity has a component, we have
to check if <code>dense[sparse[id]] == id</code> in the sparse set of the component. <code>sparse[1]</code> in
<code>SparseSet&lt;FirstComponent&gt;</code> is uninitialised and so we know that entity <code>1</code> does not have
a <code>FirstComponent</code>.</p>
<p>The next entity that contains a <code>SecondComponent</code> is <code>2</code>. However, this time, <code>sparse[2]</code>
in <code>SparseSet&lt;FirstComponent&gt;</code> is equal to <code>1</code> and <code>dense[1]</code> is equal to <code>2</code>, which means
that entity <code>2</code> has a <code>FirstComponent</code> meaning we can yield it in the iterator.</p>
<p>After iterating over all the items in the <code>SecondComponent</code> sparse set, we are done.</p>
<h3 id="removal"><a class="header" href="#removal">Removal</a></h3>
<p>Removing is done by swap removing from both <code>dense</code> and <code>data</code> and updating <code>sparse</code> in
consequence.</p>
<p>Continuing the previous example if we call:</p>
<pre><code class="language-rust noplaypen">world.remove::&lt;(FirstComponent,)&gt;(entity_id_0);</code></pre>
<p>The internal representation now looks like this:</p>
<pre><code class="language-txt">sparse: [U, U, 0, 1]
dense: [2, 3]
data: [FirstComponent(5050), FirstComponent(958)]
</code></pre>
<p><code>dense</code> and <code>data</code> shifted to the left, the first element in sparse is now uninitialised,
and the indexes at <code>sparse[2]</code> and <code>sparse[3]</code> were updated.</p>
<h3 id="additional-resources"><a class="header" href="#additional-resources">Additional Resources</a></h3>
<p><a href="https://skypjack.github.io/2019-03-07-ecs-baf-part-2/">This blog post</a> goes into more detail on sparse sets and compares them
with archetypes, another common way of representing data in ECS libraries. The blog post is
part of a larger series about the design and internals of ECS systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipes"><a class="header" href="#recipes">Recipes</a></h1>
<p>Cool patterns you may be interested in.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-an-entity-hierarchy-with-shipyard"><a class="header" href="#building-an-entity-hierarchy-with-shipyard">Building an Entity Hierarchy with Shipyard</a></h1>
<p>Hierarchies are a very commonly used organizational structure in game development. An important example is a transform hierarchy: child entities move along with their parents.</p>
<p>How can we build such a hierarchy of entities in shipyard?</p>
<p>One method is to use a secondary data structure which represents the hierarchy.</p>
<p>But an ECS already has all the means to store data: components. So let's use them!</p>
<p>Below you won't find a ready-to-use solution, rather some hints on how to start with your own hierarchy implementation, tailored to your requirements.</p>
<h2 id="parents-and-children"><a class="header" href="#parents-and-children">Parents and Children</a></h2>
<p>Think about the different roles an entity can take in a hierarchy. It can be:</p>
<ul>
<li>a parent (root node),</li>
<li>a parent and a child (intermediate node),</li>
<li>a child (leaf node).</li>
</ul>
<p>From this we can derive two simple, composable component types:</p>
<p>A <code>Parent</code> component stores the number of its children and the first child:</p>
<pre><code class="language-rust  noplaypen">struct Parent {
    num_children: usize,
    first_child: EntityId,
}</code></pre>
<p>A <code>Child</code> component links to its parent as well as neighbor siblings:</p>
<pre><code class="language-rust  noplaypen">struct Child {
    parent: EntityId,
    prev: EntityId,
    next: EntityId,
}</code></pre>
<p>As you can see, we simply store <code>EntityId</code>s to refer to other entities inside a component.</p>
<p>Note that <code>Option</code>s are completely avoided by making the sibling chain circular:</p>
<ul>
<li>Last child's <code>next</code> points to the first child.</li>
<li>First child's <code>prev</code> points to the last child.</li>
</ul>
<p>Our entire hierarchy structure resides only in <code>Parent</code> and <code>Child</code> components – nice!</p>
<p>But it'd be a hassle to create them manually each time you want to insert an entity into the tree.</p>
<h2 id="lets-make-it-convenient"><a class="header" href="#lets-make-it-convenient">Let's make it convenient</a></h2>
<p>We begin with two useful methods in a trait declaration:</p>
<pre><code class="language-rust  noplaypen">trait Hierarchy {
    // Removes the child status of an entity.
    fn detach(&amp;mut self, id: EntityId);

    // Attaches an entity as a child to a given parent entity.
    fn attach(&amp;mut self, id: EntityId, parent: EntityId);
}</code></pre>
<p>With these, you'll be able to not only insert new entities into the tree but also move a whole subtree – a child with all its descendants – to another parent.</p>
<p>Since we need access to <code>EntitiesViewMut</code> as well as our hierarchy component storages, we implement the <code>Hierarchy</code> trait for the type <code>(EntitiesViewMut&lt;'_&gt;, ViewMut&lt;'_, Parent&gt;, ViewMut&lt;'_, Child&gt;)</code>.</p>
<pre><code class="language-rust  noplaypen">fn detach(&amp;mut self, id: EntityId) {
    let (_, parents, children) = self;
    // remove the Child component - if nonexistent, do nothing
    if let Some(child) = children.remove(id) {
        // retrieve and update Parent component from ancestor
        let parent = &amp;mut parents[child.parent];
        parent.num_children -= 1;

        if parent.num_children == 0 {
            // if the number of children is zero, the Parent component must be removed
            parents.remove(child.parent);
        } else {
            // the ancestor still has children, and we have to change some linking
            // check if we have to change first_child
            if parent.first_child == id {
                parent.first_child = child.next;
            }
            // remove the detached child from the sibling chain
            children[child.prev].next = child.next;
            children[child.next].prev = child.prev;
        }
    }
}</code></pre>
<p>Before we move on to <code>attach</code>, let's make some observations.</p>
<p>We use indexing on <code>parents</code> and <code>children</code> but if the entity doesn't have the component it'll <code>unwrap</code>.</p>
<p>We don't have to worry as long as we only use the methods in our <code>Hierarchy</code> trait.</p>
<p>If you accidentally delete hierarchy components in other places without changing the linking, things will go fatally wrong. If you want to catch these errors you might want to use <code>get</code> and handle the error (for example with <code>expect</code>).</p>
<p><code>attach</code> looks like this:</p>
<pre><code class="language-rust  noplaypen">fn attach(&amp;mut self, id: EntityId, parent: EntityId) {
    // the entity we want to attach might already be attached to another parent
    self.detach(id);

    let (entities, parents, children) = self;

    // either the designated parent already has a Parent component – and thus one or more children
    if let Ok(p) = parents.get(parent) {
        // increase the parent's children counter
        p.num_children += 1;

        // get the ids of the new previous and next siblings of our new child
        let prev = children[p.first_child].prev;
        let next = p.first_child;

        // change the linking
        children[prev].next = id;
        children[next].prev = id;

        // add the Child component to the new entity
        entities.add_component(id, children, Child { parent, prev, next });
    } else {
        // in this case our designated parent is missing a Parent component
        // we don't need to change any links, just insert both components
        entities.add_component(
            id,
            children,
            Child {
                parent,
                prev: id,
                next: id,
            },
        );
        entities.add_component(
            parent,
            parents,
            Parent {
                num_children: 1,
                first_child: id,
            },
        );
    }
}</code></pre>
<p>We can now add another handy method to our trait:</p>
<pre><code class="language-rust  noplaypen">// Creates a new entity and attaches it to the given parent.
fn attach_new(&amp;mut self, parent: EntityId) -&gt; EntityId;`</code></pre>
<pre><code class="language-rust  noplaypen">fn attach_new(&amp;mut self, parent: EntityId) -&gt; EntityId {
    let id = self.0.add_entity((), ());
    self.attach(id, parent);
    id
}</code></pre>
<p>And lastly a simple usage example:</p>
<pre><code class="language-rust  noplaypen">let world = World::new();

let mut hierarchy = world.borrow::&lt;(EntitiesViewMut, ViewMut&lt;Parent&gt;, ViewMut&lt;Child&gt;)&gt;().unwrap();

let root1 = hierarchy.0.add_entity((), ());
let root2 = hierarchy.0.add_entity((), ());

let e1 = hierarchy.attach_new(root1);
let _e2 = hierarchy.attach_new(e1);
let e3 = hierarchy.attach_new(e1);
let _e4 = hierarchy.attach_new(e3);

hierarchy.attach(e3, root2);</code></pre>
<h2 id="traversing-the-hierarchy"><a class="header" href="#traversing-the-hierarchy">Traversing the hierarchy</a></h2>
<p>There are different ways the hierarchy can be queried.</p>
<p>For example, we may want to know the parent of a given entity. Doing this is simply done by inspecting its child component - if there is one.</p>
<p>However, sometimes you might need</p>
<ul>
<li>all children,</li>
<li>all ancestors,</li>
<li>or all descendants of a given entity.</li>
</ul>
<p>A perfect use case for iterators! An iterator has to implement the <code>next</code> method from the <code>Iterator</code> trait.</p>
<p>We start with a <code>ChildrenIter</code>, which is pretty straightforward:</p>
<pre><code class="language-rust  noplaypen">struct ChildrenIter&lt;C&gt; {
    get_child: C,
    cursor: (EntityId, usize),
}

impl&lt;'a, C&gt; Iterator for ChildrenIter&lt;C&gt;
where
    C: Get&lt;Out = &amp;'a Child&gt; + Copy,
{
    type Item = EntityId;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.cursor.1 &gt; 0 {
            self.cursor.1 -= 1;
            let ret = self.cursor.0;
            self.cursor.0 = self.get_child.get(self.cursor.0).unwrap().next;
            Some(ret)
        } else {
            None
        }
    }
}</code></pre>
<p>Note that we don't implement <code>Iterator</code> for <code>ViewMut&lt;Child&gt;</code> directly, but for a type that implements the <code>GetComponent</code> trait. This way, our iterator can be used with <code>View</code> as well as <code>ViewMut</code>.</p>
<p>The next one is the <code>AncestorIter</code>:</p>
<pre><code class="language-rust  noplaypen">struct AncestorIter&lt;C&gt; {
    get_child: C,
    cursor: EntityId,
}

impl&lt;'a, C&gt; Iterator for AncestorIter&lt;C&gt;
where
    C: Get&lt;Out = &amp;'a Child&gt; + Copy,
{
    type Item = EntityId;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.get_child.get(self.cursor).ok().map(|child| {
            self.cursor = child.parent;
            child.parent
        })
    }
}</code></pre>
<p>Easy.</p>
<p><code>DescendantIter</code> will be a bit more complicated. We choose to implement a depth-first variant using recursion.</p>
<p>It is based on the code for the <code>ChildrenIter</code> but comes with an additional stack to keep track of the current level the cursor is in:</p>
<ul>
<li>Push a new level to the stack if we encounter a <code>Parent</code> component.</li>
<li>Pop the last level from the stack whenever we run out of siblings, then carry on where we left off.</li>
</ul>
<pre><code class="language-rust  noplaypen">struct DescendantsIter&lt;P, C&gt; {
    get_parent: P,
    get_child: C,
    cursors: Vec&lt;(EntityId, usize)&gt;,
}

impl&lt;'a, P, C&gt; Iterator for DescendantsIter&lt;P, C&gt;
where
    P: Get&lt;Out = &amp;'a Parent&gt; + Copy,
    C: Get&lt;Out = &amp;'a Child&gt; + Copy,
{
    type Item = EntityId;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if let Some(cursor) = self.cursors.last_mut() {
            if cursor.1 &gt; 0 {
                cursor.1 -= 1;
                let ret = cursor.0;
                cursor.0 = self.get_child.get(cursor.0).unwrap().next;
                if let Ok(parent) = self.get_parent.get(ret) {
                    self.cursors.push((parent.first_child, parent.num_children));
                }
                Some(ret)
            } else {
                self.cursors.pop();
                self.next()
            }
        } else {
            None
        }
    }
}</code></pre>
<p>What we still need to do is to implement a simple trait with methods that return nicely initialized <code>*Iter</code> structs for us:</p>
<pre><code class="language-rust  noplaypen">trait HierarchyIter&lt;'a, P, C&gt; {
    fn ancestors(&amp;self, id: EntityId) -&gt; AncestorIter&lt;C&gt;;
    fn children(&amp;self, id: EntityId) -&gt; ChildrenIter&lt;C&gt;;
    fn descendants(&amp;self, id: EntityId) -&gt; DescendantsIter&lt;P, C&gt;;
}

impl&lt;'a, P, C&gt; HierarchyIter&lt;'a, P, C&gt; for (P, C)
where
    P: Get&lt;Out = &amp;'a Parent&gt; + Copy,
    C: Get&lt;Out = &amp;'a Child&gt; + Copy,
{
    fn ancestors(&amp;self, id: EntityId) -&gt; AncestorIter&lt;C&gt; {
        let (_, children) = self;

        AncestorIter {
            get_child: *children,
            cursor: id,
        }
    }

    fn children(&amp;self, id: EntityId) -&gt; ChildrenIter&lt;C&gt; {
        let (parents, children) = self;

        ChildrenIter {
            get_child: *children,
            cursor: parents
                .get(id)
                .map_or((id, 0), |parent| (parent.first_child, parent.num_children)),
        }
    }

    fn descendants(&amp;self, id: EntityId) -&gt; DescendantsIter&lt;P, C&gt; {
        let (parents, children) = self;

        DescendantsIter {
            get_parent: *parents,
            get_child: *children,
            cursors: parents.get(id).map_or_else(
                |_| Vec::new(),
                |parent| vec![(parent.first_child, parent.num_children)],
            ),
        }
    }
}</code></pre>
<p>Cool. Let's extend the former usage example into a little test.</p>
<pre><code class="language-rust  noplaypen">#[test]
fn test_hierarchy() {
    let world = World::new();

    let mut hierarchy = world.borrow::&lt;(EntitiesViewMut, ViewMut&lt;Parent&gt;, ViewMut&lt;Child&gt;)&gt;().unwrap();

    let root1 = hierarchy.0.add_entity((), ());
    let root2 = hierarchy.0.add_entity((), ());

    let e1 = hierarchy.attach_new(root1);
    let e2 = hierarchy.attach_new(e1);
    let e3 = hierarchy.attach_new(e1);
    let e4 = hierarchy.attach_new(e3);

    hierarchy.attach(e3, root2);

    let e5 = hierarchy.attach_new(e3);

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .children(e3)
        .eq([e4, e5].iter().cloned()));

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .ancestors(e4)
        .eq([e3, root2].iter().cloned()));

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .descendants(root1)
        .eq([e1, e2].iter().cloned()));

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .descendants(root2)
        .eq([e3, e4, e5].iter().cloned()));
}</code></pre>
<h2 id="removing-entities-from-the-hierarchy"><a class="header" href="#removing-entities-from-the-hierarchy">Removing entities from the hierarchy</a></h2>
<p>Removing an entity from the hierarchy means removing its <code>Parent</code> and <code>Child</code> components.</p>
<p>To remove an entity's <code>Child</code> component, we can simply reuse <code>detach</code>. Removing its <code>Parent</code> component must be done with caution. This entity's children now become orphans – we have to detach them as well.</p>
<p>Both methods can be added to our <code>Hierarchy</code> trait:</p>
<pre><code class="language-rust  noplaypen">fn remove(&amp;mut self, id: EntityId) {
    self.detach(id);

    let children = (&amp;self.1, &amp;self.2).children(id).collect::&lt;Vec&lt;_&gt;&gt;();
    for child_id in children {
        self.detach(child_id);
    }
    self.1.remove(id);
}</code></pre>
<p>A method that removes a whole subtree is easy to write by making use of recursion again:</p>
<pre><code class="language-rust  noplaypen">fn remove_all(&amp;mut self, id: EntityId) {
    let (_, parents, children) = self;

    for child_id in (&amp;*parents, &amp;*children).children(id).collect::&lt;Vec&lt;_&gt;&gt;() {
        self.remove_all(child_id);
    }
    self.remove(id);
}</code></pre>
<p>That's it! We can now add the following code to the end of our test from the last chapter:</p>
<pre><code class="language-rust  noplaypen">hierarchy.detach(e1);

assert!((&amp;hierarchy.1, &amp;hierarchy.2).descendants(root1).eq(None));
assert!((&amp;hierarchy.1, &amp;hierarchy.2).ancestors(e1).eq(None));
assert!((&amp;hierarchy.1, &amp;hierarchy.2).children(e1).eq([e2].iter().cloned()));

hierarchy.remove(e1);

assert!((&amp;hierarchy.1, &amp;hierarchy.2).children(e1).eq(None));

hierarchy.remove_all(root2);

assert!((&amp;hierarchy.1, &amp;hierarchy.2).descendants(root2).eq(None));
assert!((&amp;hierarchy.1, &amp;hierarchy.2).descendants(e3).eq(None));
assert!((&amp;hierarchy.1, &amp;hierarchy.2).ancestors(e5).eq(None));</code></pre>
<h2 id="sorting"><a class="header" href="#sorting">Sorting</a></h2>
<p>The order between siblings may or may not play a role in your project.</p>
<p>However, a simple sorting for children can be done in two steps:</p>
<ul>
<li>Collect all children into a <code>Vec</code> and sort it.</li>
<li>Adjust the linking in the <code>Child</code> components according to the sorted list.</li>
</ul>
<p>We can add this method to the <code>Hierarchy</code> trait:</p>
<pre><code class="language-rust  noplaypen">fn sort_children_by&lt;F&gt;(&amp;mut self, id: EntityId, compare: F)
where
    F: FnMut(&amp;EntityId, &amp;EntityId) -&gt; std::cmp::Ordering,
{
    let (_, parents, children_storage) = self;

    let mut children = (&amp;*parents, &amp;*children_storage)
        .children(id)
        .collect::&lt;Vec&lt;EntityId&gt;&gt;();
    if children.len() &gt; 1 {
        children.sort_by(compare);
        // set first_child in Parent component
        parents[id].first_child = children[0];
        // loop through children and relink them
        for i in 0..children.len() - 1 {
            children_storage[children[i]].next = children[i + 1];
            children_storage[children[i + 1]].prev = children[i];
        }
        children_storage[children[0]].prev = *children.last().unwrap();
        children_storage[*children.last().unwrap()].next = children[0];
    }
}</code></pre>
<p>Again a small test demonstrates the usage:</p>
<pre><code class="language-rust  noplaypen">#[test]
fn test_sorting() {
    let world = World::new();

    let (mut hierarchy, mut usizes) = world.borrow::&lt;(
        (EntitiesViewMut, ViewMut&lt;Parent&gt;, ViewMut&lt;Child&gt;),
        ViewMut&lt;usize&gt;,
    )&gt;().unwrap();

    let root = hierarchy.0.add_entity((), ());

    let e0 = hierarchy.attach_new(root);
    let e1 = hierarchy.attach_new(root);
    let e2 = hierarchy.attach_new(root);
    let e3 = hierarchy.attach_new(root);
    let e4 = hierarchy.attach_new(root);

    hierarchy.0.add_component(e0, &amp;mut usizes, 7);
    hierarchy.0.add_component(e1, &amp;mut usizes, 5);
    hierarchy.0.add_component(e2, &amp;mut usizes, 6);
    hierarchy.0.add_component(e3, &amp;mut usizes, 1);
    hierarchy.0.add_component(e4, &amp;mut usizes, 3);

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .children(root)
        .eq([e0, e1, e2, e3, e4].iter().cloned()));

    hierarchy.sort_children_by(root, |a, b| usizes[*a].cmp(&amp;usizes[*b]));

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .children(root)
        .eq([e3, e4, e1, e2, e0].iter().cloned()));
}</code></pre>
<h2 id="do-it-yourself"><a class="header" href="#do-it-yourself">Do it yourself!</a></h2>
<p>We recommend that you build your own hierarchy system fitted to your specific needs. In deviation of the above code examples you may want:</p>
<ul>
<li>a single hierarchy component instead of two,</li>
<li>breadth-first instead of depth-first traversal,</li>
<li>different sorting methods,</li>
<li>etc.</li>
</ul>
<h2 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h2>
<p>These notes are based on ideas presented in a highly recommended article by skypjack: <a href="https://skypjack.github.io/2019-06-25-ecs-baf-part-4/">ECS back and forth</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>If you're working with <a href="https://github.com/seed-rs/seed">Seed</a>, @MartinKavik ported the bunny demo to it. You can find the source <a href="https://github.com/seed-rs/seed/tree/master/examples/bunnies">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>0.4 comes with a few big changes, this chapter aims to facilitate the transition.</p>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<p>Let's start small, prelude and internal no longer exist, you just have to replace all <code>shipyard::prelude</code> and <code>shipyard::internal</code> by <code>shipyard</code>.</p>
<h2 id="systems-1"><a class="header" href="#systems-1">Systems</a></h2>
<p>Following <a href="https://github.com/leudz/shipyard/issues/75">an issue</a> opened by <a href="https://github.com/cart">@cart</a>, systems will become functions instead of an instance of the <code>System</code> trait.</p>
<p>To make this work, borrowing is now done with the actual types you get when you borrow a storage instead of using references.</p>
<p>In 0.3:</p>
<pre><code class="language-rust  noplaypen">struct MySystem;
impl&lt;'sys&gt; System&lt;'sys&gt; for MySystem {
    type Data = (
        EntitiesMut,
        &amp;mut usize,
    );
    fn run((mut entities, mut usizes): &lt;Self::Data as SystemData&lt;'sys&gt;&gt;::View) {}
}

// or with the macro

#[system(MySystem)]
fn run(mut entities: &amp;mut Entities, mut usizes: &amp;mut usize) {}</code></pre>
<p>In 0.4:</p>
<pre><code class="language-rust  noplaypen">fn my_system(mut entities: EntitiesViewMut, mut usizes: ViewMut&lt;usize&gt;) {}</code></pre>
<p>This change also affects <code>run</code> and <code>borrow</code>.<br />
<code>World::run_system</code> is no longer needed and you can run systems with <code>run</code> directly.</p>
<pre><code class="language-rust  noplaypen">world.run(my_system);

// and closures still work

world.run(|mut entities: EntitiesViewMut, mut usizes: ViewMut&lt;usize&gt;| {});</code></pre>
<p><code>run</code> has the same return type as the system or closure and it doesn't require any tuple most of the time.</p>
<p>Here's the complete list:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">0.3</th><th style="text-align: center">0.4</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>AllStorages</code> / <code>&amp;mut AllStorages</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.AllStoragesViewMut.html"><code>AllStoragesViewMut</code></a></td></tr>
<tr><td style="text-align: center"><code>Entities</code> / <code>&amp;Entities</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.EntitiesView.html"><code>EntitiesView</code></a></td></tr>
<tr><td style="text-align: center"><code>EntitiesMut</code> / <code>&amp;mut Entities</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.EntitiesViewMut.html"><code>EntitiesViewMut</code></a></td></tr>
<tr><td style="text-align: center"><code>&amp;T</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.View.html"><code>View&lt;T&gt;</code></a></td></tr>
<tr><td style="text-align: center"><code>&amp;mut T</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.ViewMut.html"><code>ViewMut&lt;T&gt;</code></a></td></tr>
<tr><td style="text-align: center"><code>ThreadPool</code> / <code>&amp;ThreadPool</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.ThreadPoolView.html"><code>ThreadPoolView</code></a></td></tr>
<tr><td style="text-align: center"><code>Unique&lt;&amp;T&gt;</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.UniqueView.html"><code>UniqueView&lt;T&gt;</code></a></td></tr>
<tr><td style="text-align: center"><code>Unique&lt;&amp;mut T&gt;</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.UniqueViewMut.html"><code>UniqueViewMut&lt;T&gt;</code></a></td></tr>
<tr><td style="text-align: center"><code>NonSend&lt;&amp;T&gt;</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSend.html"><code>NonSend&lt;View&lt;T&gt;&gt;</code></a></td></tr>
<tr><td style="text-align: center"><code>NonSend&lt;&amp;mut T&gt;</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSend.html"><code>NonSend&lt;ViewMut&lt;T&gt;&gt;</code></a></td></tr>
<tr><td style="text-align: center"><code>Unique&lt;NonSend&lt;&amp;T&gt;&gt;</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSend.html"><code>NonSend&lt;UniqueView&lt;T&gt;&gt;</code></a></td></tr>
<tr><td style="text-align: center"><code>Unique&lt;NonSend&lt;&amp;mut T&gt;&gt;</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSend.html"><code>NonSend&lt;UniqueViewMut&lt;T&gt;&gt;</code></a></td></tr>
<tr><td style="text-align: center"><code>FakeBorrow&lt;T&gt;</code></td><td style="text-align: center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.FakeBorrow.html"><code>FakeBorrow&lt;T&gt;</code></a></td></tr>
</tbody></table>
</div>
<p><a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSync.html"><code>NonSync</code></a> and <a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSendSync.html"><code>NonSendSync</code></a> follow the same pattern as <code>NonSend</code>.</p>
<h2 id="macro"><a class="header" href="#macro">Macro</a></h2>
<p>The system proc macro doesn't exist anymore. With the new system design the advantage it provides are not great enough to justify it.</p>
<h2 id="workloads-1"><a class="header" href="#workloads-1">Workloads</a></h2>
<h3 id="the-ugly"><a class="header" href="#the-ugly">The ugly</a></h3>
<p>Workloads are the only one suffering a downgrade. You'll have to give all systems twice to the function plus a few things.</p>
<p>In 0.3:</p>
<pre><code class="language-rust  noplaypen">world.add_workload&lt;(Sys1, Sys2), _&gt;(&quot;Workload1&quot;);</code></pre>
<p>In 0.4:</p>
<pre><code class="language-rust  noplaypen">world
    .add_workload(&quot;Workload1&quot;)
    .with_system((
        |world: &amp;World| world.try_run(sys1),
        sys1
    ))
    .with_system((
        |world: &amp;World| world.try_run(sys2),
        sys2
    ))
    .build();

// with a macro

world
    .add_workload(&quot;Workload1&quot;)
    .with_system(system!(sys1))
    .with_system(system!(sys2))
    .build();</code></pre>
<p>⚠️ The two arguments are wrapped in a tuple.</p>
<p>This repetition will disappear someday but I don't expect it to be soon.<br />
You don't have to use a closure, any function with <code>&amp;World</code> as argument and returning <code>Result&lt;(), shipyard::error::Run&gt;</code> are valid.<br />
It's very important to pass the same function twice, the workload might always error if this isn't the case.</p>
<h3 id="the-good"><a class="header" href="#the-good">The good</a></h3>
<p>Workloads don't come with only a downgrade. You can now return errors from systems inside workloads.</p>
<pre><code class="language-rust  noplaypen">#[derive(Debug)]
struct TerribleError;

impl Display for TerribleError {
    fn fmt(&amp;self, fmt: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), core::fmt::Error&gt; {
        Debug::fmt(self, fmt)
    }
}
impl Error for TerribleError {}

fn my_sys(mut entities: EntitiesViewMut) -&gt; Result&lt;(), TerribleError&gt; {
    Err(TerribleError)
}

fn main() {
    use shipyard::error::{Run, RunWorkload};

    let world = World::new();
    world
        .add_workload(&quot;May fail&quot;)
        .with_system((
            |world: &amp;World| world.try_run(my_sys)?.map_err(Run::from_custom),
            my_sys,
        ))
        .build();
    match world.try_run_default().map_err(RunWorkload::custom_error) {
        Err(Some(error)) =&gt; {
            assert!(error.is::&lt;TerribleError&gt;());
        }
        _ =&gt; {}
    }
}</code></pre>
<p>The error has to be anonymized so you'll get back a <code>Box&lt;dyn Error + Send&gt;</code> with std and a <code>Box&lt;dyn Any + Send&gt;</code> with no_std.<br />
Workloads stop at the first error encountered, just like 0.3.<br />
You can also use the <code>try_system!</code> macro the same way as <code>system!</code>.</p>
<pre><code class="language-rust  noplaypen">world
    .add_workload(&quot;May fail&quot;)
    .with_system(try_system!(my_sys))
    .build();</code></pre>
<p>It'll generate the same code as above.</p>
<h2 id="iterator"><a class="header" href="#iterator">Iterator</a></h2>
<p>You can now use <code>std::iter::Iterator</code> and <code>for loop</code> with views without having to call <code>into_iter</code>.<br />
All iteration code from 0.3 will still work.</p>
<pre><code class="language-rust  noplaypen">fn my_sys((mut usizes, u32s): (ViewMut&lt;usize&gt;, View&lt;u32&gt;)) {
    for (i, &amp;j) in (&amp;mut usizes, &amp;u32s).iter() {
        *i += j as usize;
    }
}</code></pre>
<h2 id="get"><a class="header" href="#get">Get</a></h2>
<p>The <code>GetComponent</code> trait has been renamed <code>Get</code>.</p>
<p>What follows is only true for 0.4. 0.5 went back to <code>get</code> returning a <code>Result</code>.<br />
<code>Get::get</code> has been renamed <code>try_get</code> and a new <code>get</code> method has been added to unwrap errors.</p>
<p>If you used <code>get</code> followed by <code>unwrap</code>, you can simply remove the <code>unwrap</code>.<br />
If you used another error handling method you'll have to replace <code>get</code> by <code>try_get</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pilgrimage"><a class="header" href="#pilgrimage">Pilgrimage</a></h1>
<p>Links and information not directly related to shipyard.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-resources"><a class="header" href="#more-resources">More Resources</a></h1>
<p><a href="https://skypjack.github.io/2019-03-21-ecs-baf-part-2-insights/">Packs</a>, the whole series is a good read<br />
<a href="https://www.youtube.com/watch?v=W3aieHjyNvw">Timothy Ford's GDC talk on ECS usage in Overwatch</a><br />
<a href="https://www.youtube.com/watch?v=aKLntZcp27M">Catherine West's closing keynote on using the ECS pattern in Rust</a><br />
<a href="https://github.com/SanderMertens/ecs-faq">Sander Mertens's ECS FAQ</a><br />
<a href="https://www.richardlord.net/blog/ecs/finite-state-machines-with-ash.html">FSM in ECS</a><br />
<a href="https://github.com/abulka/todomvc-ecs">Todo MVC using ECS</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shipyard-related-crates"><a class="header" href="#shipyard-related-crates">Shipyard Related Crates</a></h1>
<p>List of crate built on top of Shipyard.<br />
Don't hesitate to contact me if your crate uses Shipyard (it doesn't have to be prefixed with &quot;shipyard&quot;).</p>
<ul>
<li><a href="https://crates.io/crates/shipyard_hierarchy">shipyard_hierarchy</a> - by <a href="https://github.com/dakom">David Komer</a> - Hierarchy crate.</li>
<li><a href="https://crates.io/crates/shipyard_scenegraph">shipyard_scenegraph</a> - by <a href="https://github.com/dakom">David Komer</a> - Scenegraph crate.</li>
<li><a href="https://github.com/storyscript/shipyard_app">shipyard_app</a> - by <a href="https://github.com/colelawrence">Cole Lawrence</a> - WIP Plugin interface being used in a commercial project.</li>
<li><a href="https://crates.io/crates/shipyard_rapier2d">shipyard_rapier2d</a> - by <a href="https://github.com/lucaspoffo">lucaspoffo</a> - An integration with the 2D physics engine rapier.</li>
<li><a href="https://crates.io/crates/shipyard_rapier3d">shipyard_rapier3d</a> - by <a href="https://github.com/lucaspoffo">lucaspoffo</a> - An integration with the 3D physics engine rapier.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="projects-using-shipyard"><a class="header" href="#projects-using-shipyard">Projects using Shipyard</a></h1>
<p>List of project using Shipyard.<br />
Don't hesitate to contact me to get your project listed.</p>
<ul>
<li><a href="https://github.com/almetica/almetica">Almetica</a> is a server for the MMORPG TERA.</li>
<li><a href="https://github.com/BoxyUwU/guacamole-runner">Guacamole Runner</a> by <a href="https://github.com/BoxyUwU">@BoxyUwU</a> is a small game where the player is constantly falling and must jump off planes to stay in the air. When they go over the top of the dirt tiles they plant flowers which gives them points.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p><a href="https://github.com/dakom">dakom - David Komer</a><br />
<a href="https://github.com/eldyer">eldyer</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
